<!-- ------------------------------------------------------------------- -->
<!--                                                                     -->
<!--  gpd.xml          groupoids documentation            Chris Wensley  -->
<!--                                                       & Emma Moore  -->
<!--                                                                     -->
<!--  Copyright (C) 2000-2022, Emma Moore and Chris Wensley,             --> 
<!--  School of Computer Science, Bangor University, U.K.                --> 
<!--                                                                     -->
<!-- ------------------------------------------------------------------- -->

<?xml version="1.0" encoding="UTF-8"?>

<Chapter Label="chap-gpd">
<Heading>Groupoids</Heading>

A <E>groupoid</E> is a (mathematical) category in which every element
is invertible. 
It consists of a set of <E>pieces</E>, 
each of which is a connected groupoid. 
The usual terminology is `connected component', but in &GAP; `component' 
is used for `record component', so we use the term <E>single piece</E>.  
<P/>
The simplest form for a <E>single piece groupoid</E> 
is the direct product of a group and a complete digraph,
and so is determined by a set of <E>objects</E> <C>obs</C> <M>= \Omega</M> 
(the least of which is the <E>root object</E>), 
and a <E>root group</E> <C>grp</C> <M>= G</M>. 
Then the elements of the groupoid are <E>arrows</E> <M>g : o_1 \to o_2</M>, 
stored as triples <C>[g,o1,o2]</C>, where <M>g \in G</M> 
and <M>o_1,o_2 \in \Omega</M>.  
The objects will generally be chosen to be consecutive negative integers, 
but any suitable ordered set is acceptable, 
and `consecutive' is not a requirement.
The root group will usually be taken to be a permutation group,
but pc-groups, fp-groups and matrix groups are also supported. 
<P/>
A <E>group</E> may be considered as a single piece groupoid with one object.
<P/>
A <E>groupoid</E> is a set of one or more single piece groupoids, 
its <E>pieces</E>, and is represented as <C>IsGroupoidRep</C>, 
with attribute <C>PiecesOfGroupoid</C>.
<P/>
The underlying digraph of a single piece groupoid is a regular, 
complete digraph on the object set <M>\Omega</M> with 
<M>|G|</M> arrows from any one object to any other object. 
It will be convenient to specify a set of <E>rays</E> 
<Index Key="rays"></Index> 
consisting of <M>|\Omega|</M> arrows <M>r_i : o_1 \to o_i</M>, 
where <M>o_1</M> is the root object and <M>r_1</M> 
is the identity in <M>G</M>. 
In the simplest examples all the <M>r_i</M> will be identity elements, 
but rays are useful when forming subgroupoids 
(see <Ref Func="SubgroupoidWithRays"/>).
<P/>
A groupoid is <E>homogeneous</E> if it has two of more isomorphic pieces, 
with identical groups. 
The special case of <E>homogeneous, discrete</E> groupoids, 
where each piece has a single object, is given its own representation. 
These are used in the <Package>XMod</Package> package 
as the source of a crossed modules of groupoids. 
<P/> 
For the definitions of the standard properties of groupoids
we refer to R. Brown's book ``Topology'' <Cite Key="BrTop" />, 
recently revised and reissued as ``Topology and Groupoids'' 
<Cite Key="BrTopGpd" />.


<Section Label="sec-gpds">
<Heading>Groupoids: their properties and attributes</Heading>

<ManSection>
   <Oper Name="SinglePieceGroupoid"
         Arg="grp, obs" />
   <Func Name="Groupoid"
         Arg="args" />
   <Oper Name="DomainWithSingleObject"
         Arg="gp, obj" Label="for groups" />
<Description>
The simplest construction of a groupoid 
is as the direct product of a group and a complete digraph. 
Such a groupoid will be called a <Index Key="standard groupoid"> 
standard groupoid</Index> <E>standard groupoid</E>. 
Many subgroupoids of such a groupoid do not have this simple form, 
and will be considered in section <Ref Sect="sec-subgpds"/>. 
The global function <C>Groupoid</C> will normally find the appropriate 
constructor to call, the options being:
<List>
<Item>
the object group, a set of objects;
</Item>
<Item>
a group being converted to a groupoid, a single object; 
</Item>
<Item>
a list of groupoids which have already been constructed 
(see <Ref Subsect="sec-union" />). 
</Item>
</List>
<P/>
Methods for <C>ViewObj</C>, <C>PrintObj</C> and <C>Display</C> are
provided for groupoids and the other types of object in this package.
Users are advised to supply names for all the groups and groupoids 
they construct.
<P/> 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> s4 := Group( (1,2,3,4), (3,4) );; 
gap> d8 := Subgroup( s4, [ (1,2,3,4), (1,3) ] );;
gap> SetName( s4, "s4" );  SetName( d8, "d8" ); 
gap> Gs4 := SinglePieceGroupoid( s4, [-15 .. -11] ); 
single piece groupoid: < s4, [ -15 .. -11 ] >
gap> Gd8 := Groupoid( d8, [-9,-8,-7] );
single piece groupoid: < d8, [ -9, -8, -7 ] >
gap> c6 := Group( (5,6,7)(8,9) );;
gap> SetName( c6, "c6" );
gap> Gc6 := DomainWithSingleObject( c6, -6 );
single piece groupoid: < c6, [ -6 ] >
gap> SetName( Gs4, "Gs4" );  SetName( Gd8, "Gd8" );  SetName( Gc6, "Gc6" );  
]]>
</Example>

<ManSection>
   <Attr Name="ObjectList"
         Arg="gpd" Label="for groupoids" />
   <Attr Name="RootObject"
         Arg="gpd" Label="for groupoids" />
   <Attr Name="RootGroup"
         Arg="gpd" />
   <Oper Name="ObjectGroup"
         Arg="gpd, obj" />
<Description>
The <C>ObjectList</C> of a groupoid is the sorted list of its objects. 
The <C>RootObject</C> in a single-piece groupoid 
is the object with the least label. 
A <E>loop</E> is an arrow of the form <M>g : o \to o</M>, 
and the loops at a particular object <M>o</M> form a group, 
the <C>ObjectGroup</C> at <M>o</M>. 
The <C>RootGroup</C> is the <C>ObjectGroup</C> at the <C>RootObject</C>. 
<P/> 
In the example, the groupoids <C>Gf2c6</C> and <C>Gabc</C> illustrate that 
the objects need not be integers.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> ObjectList( Gs4 );
[ -15 .. -11 ] 
gap> f2 := FreeGroup(2);;
gap> Gf2c6 := Groupoid( c6, GeneratorsOfGroup(f2) );
single piece groupoid: < c6, [ f1, f2 ] >
gap> Arrow( Gf2c6, (5,7,6), f2.1, f2.2 );
[(5,7,6) : f1 -> f2]
gap> Gabc := Groupoid( d8, [ "a", "b", "c" ] );
single piece groupoid: < d8, [ "a", "b", "c" ] >
gap> Arrow( Gabc, (2,4), "c", "b" );
[(2,4) : c -> b]
]]>
</Example>

<ManSection>
   <Prop Name="IsPermGroupoid"
         Arg="gpd" />
   <Prop Name="IsPcGroupoid"
         Arg="gpd" />
   <Prop Name="IsFpGroupoid"
         Arg="gpd" />
   <Prop Name="IsMatrixGroupoid"
         Arg="gpd" />
   <Prop Name="IsFreeGroupoid"
         Arg="gpd" />
<Description>
A groupoid is a permutation groupoid if all its pieces have 
permutation groups.
Most of the examples in this chapter are permutation groupoids,
but in principle any type of group known to &GAP; may be used. 
<P/>
In the following example <C>Gf2</C> is an fp-groupoid and also a free groupoid, 
<C>Gq8</C> is a pc-groupoid, and <C>Ggl43</C> is a matrix groupoid. 
See section <Ref Sect="sec-mxreps"/> for matrix representations of groupoids. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> f2 := FreeGroup( 2 );;
gap> Gf2 := Groupoid( f2, -22 );;
gap> SetName( f2, "f2" );  SetName( Gf2, "Gf2" ); 
gap> q8 := QuaternionGroup( 8 );;
gap> Gq8 := Groupoid( q8, [ -18, -17 ] );;
gap> SetName( q8, "q8" );  SetName( Gq8, "Gq8" );
gap> gl43 := SpecialLinearGroup( 4, 3 );;
gap> Ggl43 := SinglePieceGroupoid( gl43, [ -25..-21 ] );;
gap> SetName( gl43, "gl43" );  SetName( Ggl43, "Ggl43" );
gap> [ IsMatrixGroupoid( Ggl43 ), IsFpGroupoid( Gf2 ), IsFreeGroupoid( Gf2 ),
>      IsPcGroupoid( Gq8 ), IsPermGroupoid( Gs4 ) ]; 
[ true, true, true, true, true ]
]]>
</Example>

<ManSection Label="sec-union">
   <Oper Name="UnionOfPieces" 
         Arg="pieces" Label="for groupoids" />
   <Attr Name="Pieces"
         Arg="gpd" Label="for groupoids" />
   <Attr Name="Size"
         Arg="gpd" />
   <Oper Name="ReplaceOnePieceInUnion" 
         Arg="U, old_piece, new_piece" />
<Description>
When a groupoid consists of two or more pieces, 
we require their object lists to be disjoint. 
The operation <C>UnionOfPieces</C> and the attribute <C>Pieces</C>,  
introduced in section <Ref Sect="sec-pieces"/>, are also used for groupoids. 
The pieces are sorted by the least object in their object lists. 
The <Index Key="ObjectList" Subkey="for groupoids"> <C>ObjectList</C> </Index> 
<C>ObjectList</C> is the sorted concatenation of the objects in the pieces.
<P/>
The <C>Size</C> of a groupoid is the number of its arrows. 
For a single piece groupoid, this is the product of the size of the group 
with the square of the number of objects. 
For a non-connected groupoid, the size is the sum of the sizes of its pieces. 
<P/>
One of the pieces in a groupoid may be replaced by an alternative piece 
using the operation <C>ReplaceOnePieceInUnion</C>. 
The <E>old_piece</E> may be either the <E>position</E> of the piece to be replaced, or one of the pieces in <C>U</C>.  
The objects in the new piece may or may not overlap the objects 
in the piece being removed -- 
we just require that the object lists in the new union are disjoint. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> U3 := UnionOfPieces( [ Gc6, Gd8, Gs4 ] );;
gap> Display( U3 );
groupoid with 3 pieces:
< objects: [ -15 .. -11 ]
    group: s4 = <[ (1,2,3,4), (3,4) ]> >
< objects: [ -9, -8, -7 ]
    group: d8 = <[ (1,2,3,4), (1,3) ]> >
< objects: [ -6 ]
    group: c6 = <[ (5,6,7)(8,9) ]> >
gap> Pieces( U3 );
[ Gs4, Gd8, Gc6 ]
gap> ObjectList( U3 );
[ -15, -14, -13, -12, -11, -9, -8, -7, -6 ]
gap> U2 := Groupoid( [ Gf2, Gq8 ] );;
gap> [ Size(Gs4), Size(Gd8), Size(Gc6), Size(U3) ];
[ 600, 72, 6, 678 ]
gap> [ Size(Gf2), Size(Gq8), Size(U2) ];           
[ infinity, 32, infinity ]
gap> U5 := UnionOfPieces( [ U3, U2 ] );
groupoid with 5 pieces:
[ Gf2, Gq8, Gs4, Gd8, Gc6 ]
gap> Display( U5 );
groupoid with 5 pieces:
< objects: [ -22 ]
    group: f2 = <[ f1, f2 ]> >
< objects: [ -18, -17 ]
    group: q8 = <[ x, y, y2 ]> >
< objects: [ -15 .. -11 ]
    group: s4 = <[ (1,2,3,4), (3,4) ]> >
< objects: [ -9, -8, -7 ]
    group: d8 = <[ (1,2,3,4), (1,3) ]> >
< objects: [ -6 ]
    group: c6 = <[ (5,6,7)(8,9) ]> >
gap> ## in the next example the object lists are not disjoint 
gap> UnionOfPieces( [ Gf2, Ggl43 ] ); 
fail
gap> V3 := ReplaceOnePieceInUnion( U3, Gd8, Gq8 ); 
groupoid with 3 pieces:
[ Gq8, Gs4, Gc6 ]
gap> ObjectList( V3 );             
[ -18, -17, -15, -14, -13, -12, -11, -6 ]
gap> U3 = V3;
false
gap> V2 := ReplaceOnePieceInUnion( U2, 2, Gd8 ); 
groupoid with 2 pieces:
[ Gf2, Gd8 ]
]]>
</Example>

<ManSection>
   <Oper Name="HomogeneousGroupoid" 
         Arg="gpd, oblist" />
   <Oper Name="HomogeneousDiscreteGroupoid" 
         Arg="gp, obs" />
   <Attr Name="PieceIsomorphisms" 
         Arg="hgpd" />
<Description>
Special functions are provided for the case where a groupoid has 
more than one connected component, and when these components are identical 
except for their object sets. 
Such groupoids are said to be <E>homogeneous</E>. 
<P/>
The operation <C>HomogeneousGroupoid</C> is used when the components 
each contain more than one object. 
The arguments consist of a single piece groupoid <C>gpd</C> 
and a list of lists of objects <C>oblist</C>, 
each of whose lists has the same length as the object list 
<C>obs</C> of <C>gpd</C>. 
Note that <C>gpd</C> is <E>not</E> included as one of the pieces in the output 
unless <C>obs</C> is included as one of the lists in <C>oblist</C>. 
<P/>
The operation <C>HomogeneousDiscreteGroupoid</C> is used 
when the components each have a single object. 
In this case the first argument is just a group -- 
the root group for each component. 
These groupoids are used in the <Package>XMod</Package> package 
as the source of many crossed modules of groupoids. 
<P/>
Both types of groupoid have the property 
<Index Key="IsHomogeneousDomainWithObjects">  <C>IsHomogeneousDomainWithObjects</C> </Index> 
<C>IsHomogeneousDomainWithObjects</C>. 
In the latter case a separate representation 
<Index Key="IsHomogeneousDomainWithObjectsRep">  <C>IsHomogeneousDiscreteGroupoidRep</C> </Index> 
<C>IsHomogeneousDiscreteGroupoidRep</C> is used. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Hd8 := HomogeneousGroupoid( Gd8, 
>               [ [-20,-19,-18], [-12,-11,-10], [-16,-15,-14] ] );
homogeneous groupoid with 3 pieces:
1:  single piece groupoid: < d8, [ -20, -19, -18 ] >
2:  single piece groupoid: < d8, [ -16, -15, -14 ] >
3:  single piece groupoid: < d8, [ -12, -11, -10 ] >
gap> Size(Hd8);   ## 8x3x3 + 8x3x3
216
gap> IsHomogeneousDomainWithObjects( Hd8 );               
true
gap> PieceIsomorphisms( Hd8 );
[ groupoid homomorphism : 
    [ [ [(1,2,3,4) : -20 -> -20], [(1,3) : -20 -> -20], [() : -20 -> -19], 
          [() : -20 -> -18] ], 
      [ [(1,2,3,4) : -16 -> -16], [(1,3) : -16 -> -16], [() : -16 -> -15], 
          [() : -16 -> -14] ] ], groupoid homomorphism : 
    [ [ [(1,2,3,4) : -20 -> -20], [(1,3) : -20 -> -20], [() : -20 -> -19], 
          [() : -20 -> -18] ], 
      [ [(1,2,3,4) : -12 -> -12], [(1,3) : -12 -> -12], [() : -12 -> -11], 
          [() : -12 -> -10] ] ] ]
gap> Hc6 := HomogeneousDiscreteGroupoid( c6, [-7..-4] ); 
homogeneous, discrete groupoid: < c6, [ -7 .. -4 ] >
gap> Size( Hc6 );   ## 6x4
24
gap> RepresentationsOfObject( Gd8 );
[ "IsComponentObjectRep", "IsAttributeStoringRep", "IsMWOSinglePieceRep" ]
gap> RepresentationsOfObject( Hd8 );
[ "IsComponentObjectRep", "IsAttributeStoringRep", "IsPiecesRep" ]
gap> RepresentationsOfObject( Hc6 );
[ "IsComponentObjectRep", "IsAttributeStoringRep", 
  "IsHomogeneousDiscreteGroupoidRep" ]
gap> ktpo := KnownTruePropertiesOfObject( Hc6 );; 
gap> ans := 
> [ "IsDuplicateFree", "IsAssociative", "IsCommutative", 
>   "IsDiscreteDomainWithObjects", "IsHomogeneousDomainWithObjects" ];;
gap> ForAll( ans, a -> ( a in ktpo ) ); 
true
]]>
</Example>

<ManSection>
   <Oper Name="DirectProductOp" 
         Arg="list, gpd" />
   <Oper Name="Projection" 
         Arg="gpd, pos" />
   <Oper Name="Embedding" 
         Arg="gpd, pos" />
<Description>
The direct product of groupoids <M>G,H</M> has as group the direct product 
of the groups in <M>G</M> and <M>H</M> and as object list the cartesian 
product of their object lists. 
As usual with <C>DirectProductOp</C> the two parameters are a list of groupoids 
followed by the first entry in the list. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> prod := DirectProductOp( [Gd8,Gc6], Gd8 );
single piece groupoid: < Group( [ (1,2,3,4), (1,3), (5,6,7)(8,9) ] ), 
[ [ -9, -6 ], [ -8, -6 ], [ -7, -6 ] ] >
gap> Projection( prod, 1 );                    
groupoid homomorphism : 
[ [ [(1,2,3,4) : [ -9, -6 ] -> [ -9, -6 ]], [(1,3) : [ -9, -6 ] -> [ -9, -6 ]]
        , [(5,6,7)(8,9) : [ -9, -6 ] -> [ -9, -6 ]], 
      [() : [ -9, -6 ] -> [ -8, -6 ]], [() : [ -9, -6 ] -> [ -7, -6 ]] ], 
  [ [(1,2,3,4) : -9 -> -9], [(1,3) : -9 -> -9], [() : -9 -> -9], 
      [() : -9 -> -8], [() : -9 -> -7] ] ]
gap> Embedding( prod, 2 );                        
groupoid homomorphism : 
[ [ [(5,6,7)(8,9) : -6 -> -6] ], 
  [ [(5,6,7)(8,9) : [ -9, -6 ] -> [ -9, -6 ]] ] ]
gap> DirectProductInfo( prod );
rec( embeddings := [ , groupoid homomorphism : 
        [ [ [(5,6,7)(8,9) : -6 -> -6] ], 
          [ [(5,6,7)(8,9) : [ -9, -6 ] -> [ -9, -6 ]] ] ] ], first := Gd8, 
  groupoids := [ Gd8, Gc6 ], groups := [ d8, c6 ], 
  objectlists := [ [ -9, -8, -7 ], [ -6 ] ], 
  projections := [ groupoid homomorphism : 
        [ [ [(1,2,3,4) : [ -9, -6 ] -> [ -9, -6 ]], 
              [(1,3) : [ -9, -6 ] -> [ -9, -6 ]], 
              [(5,6,7)(8,9) : [ -9, -6 ] -> [ -9, -6 ]], 
              [() : [ -9, -6 ] -> [ -8, -6 ]], 
              [() : [ -9, -6 ] -> [ -7, -6 ]] ], 
          [ [(1,2,3,4) : -9 -> -9], [(1,3) : -9 -> -9], [() : -9 -> -9], 
              [() : -9 -> -8], [() : -9 -> -7] ] ] ] )
]]>
</Example>

</Section>


<Section Label="sec-elements">
<Heading>Groupoid elements; stars; costars; homsets</Heading>

<ManSection>
   <Oper Name="GroupoidElement"
         Arg="gpd, elt, tail, head" />
   <Oper Name="ElementOfArrow"
         Arg="elt" Label="for groupoids" />
   <Oper Name="TailOfArrow"
         Arg="elt" Label="for groupoids" />
   <Oper Name="HeadOfArrow"
         Arg="elt" Label="for groupoids" />
<Description> 
<Index Key="Arrow" Subkey="for groupoid elements"> <C>Arrow</C> </Index>
The operation <C>GroupoidElement</C> is a synonym for the operation 
<C>Arrow</C>, as described in subsection <Ref Sect="man-arrow"/>. 
To recapitulate, an arrow <C>e</C> consists of 
a group element, <C>ElementOfArrow(e)</C>; 
the tail (source) object, <C>TailOfArrow(e)</C>;
and the head (target) object, <C>HeadOfArrow(e)</C>.
Arrows have a <E>partial composition</E>: 
two arrows may be multiplied when the head of the first 
coincides with the tail of the second. 
If an attempt is made to multiply arrows where this condition does not hold, 
then the value <C>fail</C> is returned. 
<P/>
</Description>
</ManSection>
<Index>* for groupoid elements</Index>
<Example>
<![CDATA[
gap> e1 := GroupoidElement( Gd8, (1,2,3,4), -9, -8 );
[(1,2,3,4) : -9 -> -8]
gap> e2 := Arrow( Gd8, (1,3), -8, -7 );
[(1,3) : -8 -> -7]
gap> Print( [ ElementOfArrow(e1), TailOfArrow(e1), HeadOfArrow(e1) ], "\n" );
[ (1,2,3,4), -9, -8 ]
gap> e1e2 := e1*e2;
[(1,2)(3,4) : -9 -> -7]
gap> e2*e1;
fail
gap> e3 := Arrow( Gd8, (2,4), -7, -9 );;
gap> loop := e1e2*e3;
[(1,4,3,2) : -9 -> -9]
gap> loop^2;
[(1,3)(2,4) : -9 -> -9]
]]>
</Example>

<ManSection>
   <Oper Name="IdentityArrow"
         Arg="gpd, obj" />
<Description>
The identity arrow <M>1_o</M> of <M>G</M> at object <M>o</M> 
is <M>(e:o \to o)</M> where <M>e</M> is the identity element in the 
object group. 
The <Index Key="inverse arrow"> inverse arrow </Index>
<E>inverse arrow</E> <M>e^{-1}</M> of <M>e = (c : p \to q)</M> is 
<M>(c^{-1} : q \to p)</M>, 
so that <M>e*e^{-1}=1_p</M> and <M>e^{-1}*e = 1_q</M>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> i8 := IdentityArrow( Gd8, -8 );
[() : -8 -> -8]
gap> [ e1*i8, i8*e1, e1^-1]; 
[ [(1,2,3,4) : -9 -> -8], fail, [(1,4,3,2) : -8 -> -9] ]
]]>
</Example>

<ManSection>
   <Attr Name="Order"
         Arg="arr" />
<Description>
A groupoid element is a <Index Key="loop"> loop </Index> <E>loop</E> 
when the tail and head coincide. 
In this case the order of the element is defined to be 
the order of its group element.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> [ i8, loop ]; 
[ [() : -8 -> -8], [(1,4,3,2) : -9 -> -9] ]
gap> [ Order( i8 ), Order(loop) ];
[ 1, 4 ]
]]>
</Example>

<ManSection>
   <Oper Name="ObjectStar"
         Arg="gpd, obj" />
   <Oper Name="ObjectCostar"
         Arg="gpd, obj" />
   <Oper Name="Homset"
         Arg="gpd, tail, head" />
<Description>
<Index Key="star"></Index>
<Index Key="costar"></Index>
The <E>star</E> at <C>obj</C> is the set of arrows 
which have <C>obj</C> as tail,
while the <E>costar</E> is the set of arrows which have <C>obj</C> as head.
The <E>homset</E> from <C>obj1</C> to <C>obj2</C>
is the set of arrows with the specified tail and head, 
and so is bijective with the elements of the object groups. 
Thus every star and every costar is a union of homsets. 
The identity arrow at an object is a left identity for the star 
and a right identity for the costar at that object.
<P/>
In order not to create unneccessarily long lists, 
these operations return objects of type <C>IsHomsetCosetsRep</C> 
for which an <C>Iterator</C> is provided. 
(An <C>Enumerator</C> is not yet implemented.)
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> star9 := ObjectStar( Gd8, -9 );
<star at -9 with vertex group d8>
gap> Size( star9 ); 
24
gap> ## PrintSelection( star9, 19, 1 ); 
gap> iter := Iterator( star9 );;              
gap> for i in [1..18] do a := NextIterator( iter ); od; 
gap> for i in [19..24] do Print( i, " : ", NextIterator( iter ), "\n" ); od; 
19 : [(1,2,3,4) : -9 -> -9]
20 : [(1,2,3,4) : -9 -> -8]
21 : [(1,2,3,4) : -9 -> -7]
22 : [(1,2)(3,4) : -9 -> -9]
23 : [(1,2)(3,4) : -9 -> -8]
24 : [(1,2)(3,4) : -9 -> -7]
gap> costar6 := ObjectCostar( Gc6, -6 );
<costar at -6 with vertex group c6>
gap> Size( costar6 ); 
6
gap> hsetq8 := Homset( Gq8, -18, -17 );
<homset -18 -> -17 with head group q8>
gap> Perform( hsetq8, Display );
[<identity> of ... : -18 -> -17]
[y2 : -18 -> -17]
[y : -18 -> -17]
[y*y2 : -18 -> -17]
[x : -18 -> -17]
[x*y2 : -18 -> -17]
[x*y : -18 -> -17]
[x*y*y2 : -18 -> -17]
]]>
</Example>

</Section>



<Section Label="sec-subgpds">
<Heading>Subgroupoids</Heading>

<ManSection>
   <Func Name="Subgroupoid"
         Arg="args" />
   <Oper Name="IsSubgroupoid"
         Arg="gpd, sgpd" />
   <Oper Name="IsWideSubgroupoid"
         Arg="gpd, sgpd" />
<Description>
A <E>subgroupoid</E> <M>S</M> of a groupoid <M>G</M> has as objects 
some subset of the objects of <M>G</M>.
It is <E>wide</E> in <M>G</M> if both groupoids have the same object set.
It is <E>full</E> if, for any two objects in <M>S</M>, 
the <C>Homset</C> is the same as that in <M>G</M>.
The arrows of <M>S</M> are a subset of those of <M>G</M>,
closed under multiplication and
with tail and head in the chosen object set.
<P/>
There are a variety of constructors for a subgroupoid of a standard groupoid, 
as described in for following sections. 
The global function <C>Subgroupoid</C> should call the operation 
appropriate to the parameters provided. 
<P/>
</Description>
</ManSection>

<ManSection>
   <Oper Name="SubgroupoidWithRays"
         Arg="gpd, sgp, rays" />
   <Oper Name="RaysOfGroupoid"
         Arg="gpd" />
   <Oper Name="RayArrowsOfGroupoid"
         Arg="gpd" />
<Description>
If groupoid <M>G</M> is of type <C>IsDirectProductWithCompleteDigraph</C> 
with group <M>g</M> and <M>n</M> objects, 
then a typical wide subgroupoid <M>H</M> of <M>G</M> is formed by choosing 
a subgroup <M>h</M> of <M>g</M> to be the object group 
at the root object <M>q</M>, and an arrow  
<M>r : q \to p</M> for each of the objects <M>p</M>. 
The chosen loop arrow at <M>q</M> must be the identity arrow. 
These <M>n</M> arrows are called the <E>ray arrows</E> of the subgroupoid. 
The arrows in the homset from <M>p</M> to <M>p'</M> have the form 
<M>r^{-1}xr'</M> where <M>r,r'</M> are the rays from <M>q</M> 
to <M>p,p'</M> respectively, and <M>x \in h</M>. 
<P/>
The operation <C>RayArrowsOfGroupoid</C> returns a list of arrows, 
one for each object, while the operation <C>RaysOfGroupoid</C> 
returns the list of group elements in these arrows. 
<P/>
Note that it is also possible to construct a subgroupoid with rays 
of a subgroupoid with rays. 
<P/> 
In the following example we construct a subgroupoid <C>Ua4</C> 
of the groupoid <C>Gs4</C>, and then a second subgroupoid <C>Uc3</C>. 
The initial standard groupoid <C>Gs4</C> is set as the parent for 
both <C>Ua4</C> and <C>Uc3</C>.   
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> a4 := Subgroup( s4, [ (1,2,3), (2,3,4) ] );; 
gap> SetName( a4, "a4" ); 
gap> Ua4 := SubgroupoidWithRays( Gs4, a4, [(),(1,2),(2,3),(3,4),(1,4)] );      
single piece groupoid with rays: < a4, [ -15 .. -11 ], 
[ (), (1,2), (2,3), (3,4), (1,4) ] >
gap> IsSubgroupoid( Gs4, Ua4 );
true
gap> IsWideSubgroupoid( Gs4, Ua4 );
true
gap> RaysOfGroupoid( Ua4 );       
[ (), (1,2), (2,3), (3,4), (1,4) ]
gap> RayArrowsOfGroupoid( Ua4 );  
[ [() : -15 -> -15], [(1,2) : -15 -> -14], [(2,3) : -15 -> -13], 
  [(3,4) : -15 -> -12], [(1,4) : -15 -> -11] ]
gap> c3 := Subgroup( a4, [ (1,2,3) ] );; 
gap> SetName( c3, "c3" ); 
gap> Uc3 := SubgroupoidWithRays( Ua4, c3, 
>               [ (), (1,2,3,4), (1,3), (2,4), (1,4,3,2) ] );
single piece groupoid with rays: < c3, [ -15 .. -11 ], 
[ (), (1,2,3,4), (1,3), (2,4), (1,4,3,2) ] >
gap> ObjectGroup( Uc3, -14 );
Group([ (2,3,4) ])
gap> Ha4 := HomogeneousGroupoid( Ua4, [ [-25..-21], [-35..-31] ] );
homogeneous groupoid with 2 pieces:
1:  single piece groupoid with rays: < a4, [ -35 .. -31 ], 
[ (), (1,2), (2,3), (3,4), (1,4) ] >
2:  single piece groupoid with rays: < a4, [ -25 .. -21 ], 
[ (), (1,2), (2,3), (3,4), (1,4) ] >
]]>
</Example>

<ManSection>
   <Oper Name="SubgroupoidByObjects"
         Arg="gpd, obs" />
   <Attr Name="SubgroupoidBySubgroup"
         Arg="gpd sgp" />
<Description>
The <C>SubgroupoidByObjects</C> of a groupoid <C>gpd</C> 
on a subset <C>obs</C> of its objects 
contains all the arrows of <C>gpd</C> with tail and head in <C>obs</C>.
<P/>
The <C>SubgroupoidBySubgroup</C> of a connected groupoid <C>gpd</C> 
determinded by a subgroup <C>sgp</C> of the root group is the wide subgroupoid 
with root group <C>sgp</C> and containing the rays of <C>gpd</C>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Va4 := SubgroupoidByObjects( Ua4, [-14,-13,-12] );  
single piece groupoid with rays: < Group( [ (1,3,2), (1,3,4) ] ), 
[ -14, -13, -12 ], [ (), (1,3,2), (1,2)(3,4) ] >
gap> Vc3 := SubgroupoidBySubgroup( Va4, c3 );
single piece groupoid with rays: < c3, [ -14, -13, -12 ], 
[ (), (1,3,2), (1,2)(3,4) ] >
]]>
</Example>

<ManSection>
   <Oper Name="SubgroupoidByPieces"
         Arg="gpd, pieces" />
<Description>
The most general way to construct a subgroupoid is to use the operation <C>SubgroupoidByPieces</C>. 
Its two parameters are a groupoid and a list of <E>pieces</E>, 
each piece being specified either as a list <C>[sgp,obs]</C>,  
where <C>sgp</C> is a subgroup of the root group in that piece, 
and <C>obs</C> is a subset of the objects in that piece, 
or as a list <C>[sgp,obs,rays]</C> when a set of rays is required. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Display(Gd8);
single piece groupoid: Gd8
  objects: [ -9, -8, -7 ]
    group: d8 = <[ (1,2,3,4), (1,3) ]>
gap> c4 := Subgroup( d8, [ (1,2,3,4) ] );;
gap> k4 := Subgroup( d8, [ (1,3), (2,4) ] );;
gap> SetName( c4, "c4" );  SetName( k4, "k4" );
gap> Ud8 := Subgroupoid( Gd8, [ [ k4, [-9] ], [ c4, [-8,-7] ] ] );;
gap> SetName( Ud8, "Ud8" );
gap> Display( Ud8 );
groupoid with 2 pieces:
< objects: [ -9 ]
    group: k4 = <[ (1,3), (2,4) ]> >
< objects: [ -8, -7 ]
    group: c4 = <[ (1,2,3,4) ]> >
gap> [ Parent( Ud8 ), IsWideSubgroupoid( Gd8, Ud8 ) ]; 
[ Gd8, true ]
gap> U2;
groupoid with 2 pieces:
[ Gf2, Gq8 ]
gap> genf2b := List( GeneratorsOfGroup(f2), g -> g^2 );
[ f1^2, f2^2 ]
gap> f2b := Subgroup( f2, genf2b );;
gap> SU2 := SubgroupoidByPieces( U2, [ [q8,[-17]], [f2b,[-22]] ] );
groupoid with 2 pieces:
1:  single piece groupoid: < Group( [ f1^2, f2^2 ] ), [ -22 ] >
2:  single piece groupoid: < q8, [ -17 ] >
gap> IsWideSubgroupoid( U2, SU2 );
false
gap> IsSubgroupoid( Gf2, Groupoid( f2b, [-22] ) );
true
]]>
</Example>

<ManSection>
   <Attr Name="FullTrivialSubgroupoid"
         Arg="gpd" />
   <Attr Name="DiscreteTrivialSubgroupoid"
         Arg="gpd" />
<Description>
A <Index Key="trivial subgroupoid"> trivial subgroupoid </Index> 
<E>trivial subgroupoid</E> 
has trivial object groups, but need not be discrete.
A single piece trivial groupoid is sometimes called a 
<Index Key="tree groupoid"> tree groupoid </Index> <E>tree groupoid</E>.
(The term <Index Key="identity subgroupoid"> identity subgroupoid </Index> 
<E>identity subgroupoid</E> was used in versions up to 1.14.)  
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> FullTrivialSubgroupoid( Ud8 );
groupoid with 2 pieces:
1:  single piece groupoid: < id(k4), [ -9 ] >
2:  single piece groupoid: < id(c4), [ -8, -7 ] >
gap> DiscreteTrivialSubgroupoid( Ud8 );
groupoid with 3 pieces:
1:  single piece groupoid: < id(k4), [ -9 ] >
2:  single piece groupoid: < id(c4), [ -8 ] >
3:  single piece groupoid: < id(c4), [ -7 ] >
]]>
</Example>

<ManSection>
   <Oper Name="DiscreteSubgroupoid"
         Arg="gpd, sgps, obs" />
   <Attr Name="MaximalDiscreteSubgroupoid"
         Arg="gpd" />
<Description>
A subgroupoid is <E>discrete</E> if it is a union of groups. 
The <C>MaximalDiscreteSubgroupoid</C> of <C>gpd</C> 
is the union of all the single-object full subgroupoids of <C>gpd</C>.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> U3;
groupoid with 3 pieces:
[ Gs4, Gd8, Gc6 ]
gap> DiscreteSubgroupoid( U3, [ a4, a4, c4, k4 ], [-15,-11,-9,-7] );
groupoid with 4 pieces:
1:  single piece groupoid: < a4, [ -15 ] >
2:  single piece groupoid: < a4, [ -11 ] >
3:  single piece groupoid: < c4, [ -9 ] >
4:  single piece groupoid: < k4, [ -7 ] >
gap> MaximalDiscreteSubgroupoid( Vc3 );
groupoid with 3 pieces:
1:  single piece groupoid: < c3, [ -14 ] >
2:  single piece groupoid: < Group( [ (1,2,3) ] ), [ -13 ] >
3:  single piece groupoid: < Group( [ (1,4,2) ] ), [ -12 ] >
]]>
</Example>

<ManSection>
   <Oper Name="SinglePieceSubgroupoidByGenerators"
         Arg="parent, gens" />
<Description>
A set of arrows generates a groupoid by taking all possible 
products and inverses.  
So far, the only implementation is for the case of loops generating a 
group at an object <M>o</M> together with a set of rays from <M>o</M>, 
where <M>o</M> is <E>not</E> the least object. 
A suitably large supergroupoid, which must be a direct product with a 
complete digraph, should be provided. 
This is the case needed for <C>ConjugateGroupoid</C> 
in section <Ref Sect="subsec-conjgpd"/>. 
Other cases will be added as time permits. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> a1 := Arrow( Ua4, (2,3,4), -15, -15 );
gap> a2 := Arrow( Ua4, (1,2,3,4), -15, -13 );
gap> a3 := Arrow( Ua4, (2,3), -15, -11 );
gap> SinglePieceSubgroupoidByGenerators( Ua4, [a1,a2,a3] );
single piece groupoid with rays: < Group( [ (2,3,4) ] ), [ -15, -13, -11 ], 
[ (), (1,2,3,4), (2,3) ] >
]]>
</Example>

</Section>



<Section Label="sec-cosets">
<Heading>Left, right and double cosets</Heading>

<Index Key="Cosets (left,right,double)"></Index>
<Index Key="double coset"></Index>
<ManSection>
   <Oper Name="RightCoset"
         Arg="G, U, elt" />
   <Oper Name="RightCosetRepresentatives"
         Arg="G, U" />
   <Oper Name="RightCosets"
         Arg="G, U" />
   <Oper Name="LeftCoset"
         Arg="G, U, elt" />
   <Oper Name="LeftCosetRepresentatives"
         Arg="G, U" />
   <Oper Name="LeftCosetRepresentativesFromObject"
         Arg="G, U, obj" />
   <Oper Name="LeftCosets"
         Arg="G, U" />
   <Oper Name="DoubleCoset"
         Arg="G, U, V, elt" />
   <Oper Name="DoubleCosetRepresentatives"
         Arg="G, U, V" />
   <Oper Name="DoubleCosets"
         Arg="G, U, V" />
<Description>
If <C>U</C> is a subgroupoid of <M>G</M>, 
the <E>right cosets</E> <M>Ug</M> of <M>U</M> in <M>G</M>
are the equivalence classes for the relation on the arrows of <M>G</M>
where  <M>g1</M> is related to <M>g2</M> if and only if <M>g2 = u*g1</M>
for some arrow <M>u</M> of <M>U</M>.
The right coset containing <M>g</M> is written <M>Ug</M>.
These right cosets partition the costars of <M>G</M> and, 
in particular, the costar <M>U1\_{o}</M> of <M>U</M> at object <M>o</M>. 
So (unlike groups) <M>U</M> is itself a coset only when 
<M>G</M> has a single object. 
<P/>
The <E>right coset representatives</E> for <M>U</M> in <M>G</M> 
form a list containing one arrow for each coset where, 
in a particular piece of <M>U</M>, 
the group element chosen is the right coset representative 
of the group of <M>U</M> in the group of <M>G</M>.
<P/>
Similarly, the <E>left cosets</E> <M>gU</M> refine the stars of <M>G</M> 
while <E>double cosets</E> are unions of left and right cosets.
The operation <C>LeftCosetRepresentativesFromObject( G, U, obj )</C> 
is used in Chapter <Ref Sect="chap-ggraph"/> , 
and returns only those representatives which have tail at <C>obj</C>. 
<P/>
As with stars and homsets, these cosets are implemented with representation 
<C>IsHomsetCosetsRep</C> and provided with an iterator.
Note that, when <M>U</M> has more than one piece, 
cosets may have differing lengths.
<P/>
In the example the representative for the right coset <C>re2</C> is the 
tenth one in the printed list <C>rcrd8</C>, namely <C>[(2,4):-7->-7]</C>. 
<P/>
Note that operations for double cosets are a recent addition, 
and may need further work.  
<P/> 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> re2 := RightCoset( Gd8, Ud8, e2 );
<right coset of single piece groupoid: < c4, [ -8, -7 ] > 
with representative [(1,3) : -8 -> -7]>
gap> Perform( re2, Display );
[(1,3) : -8 -> -7]
[(1,3) : -7 -> -7]
[(2,4) : -8 -> -7]
[(2,4) : -7 -> -7]
[(1,4)(2,3) : -8 -> -7]
[(1,4)(2,3) : -7 -> -7]
[(1,2)(3,4) : -8 -> -7]
[(1,2)(3,4) : -7 -> -7]
gap> rcrd8 := RightCosetRepresentatives( Gd8, Ud8 );
[ [() : -9 -> -9], [(1,4,3,2) : -9 -> -9], [() : -9 -> -8], 
  [(1,4,3,2) : -9 -> -8], [() : -9 -> -7], [(1,4,3,2) : -9 -> -7], 
  [() : -8 -> -8], [(2,4) : -8 -> -8], [() : -7 -> -7], [(2,4) : -7 -> -7], 
  [() : -8 -> -9], [(2,4) : -8 -> -9] ]
gap> le2 := LeftCoset( Gd8, Ud8, e2 ); 
<left coset of single piece groupoid: < c4, [ -8, -7 ] > with representative [
(1,3) : -8 -> -8]>
gap> Perform( le2, Display );
[(1,3) : -8 -> -8]
[(1,3) : -8 -> -7]
[(2,4) : -8 -> -8]
[(2,4) : -8 -> -7]
[(1,4)(2,3) : -8 -> -8]
[(1,4)(2,3) : -8 -> -7]
[(1,2)(3,4) : -8 -> -8]
[(1,2)(3,4) : -8 -> -7]
gap> lcrd8 := LeftCosetRepresentatives( Gd8, Ud8 );
[ [() : -9 -> -9], [(1,2,3,4) : -9 -> -9], [() : -8 -> -9], 
  [(1,2,3,4) : -8 -> -9], [() : -7 -> -9], [(1,2,3,4) : -7 -> -9], 
  [() : -8 -> -8], [(2,4) : -8 -> -8], [() : -7 -> -7], [(2,4) : -7 -> -7], 
  [() : -9 -> -8], [(2,4) : -9 -> -8] ]
gap> lcr7 := LeftCosetRepresentativesFromObject( Gd8, Ud8, -7 );
[ [() : -7 -> -9], [(1,2,3,4) : -7 -> -9], [() : -7 -> -7], 
  [(2,4) : -7 -> -7] ]
gap> de2 := DoubleCoset( Gd8, Ud8, Ud8, e2 );
<double coset of [ single piece groupoid: < c4, [ -8, -7 ] >, 
  single piece groupoid: < c4, [ -8, -7 ] > ] with representative [(1,3) : 
-8 -> -8]>
gap> Perform( de2, Display );
[(2,4) : -8 -> -8]
[(2,4) : -8 -> -7]
[(2,4) : -7 -> -8]
[(2,4) : -7 -> -7]
[(1,3) : -8 -> -8]
[(1,3) : -8 -> -7]
[(1,3) : -7 -> -8]
[(1,3) : -7 -> -7]
[(1,2)(3,4) : -8 -> -8]
[(1,2)(3,4) : -8 -> -7]
[(1,2)(3,4) : -7 -> -8]
[(1,2)(3,4) : -7 -> -7]
[(1,4)(2,3) : -8 -> -8]
[(1,4)(2,3) : -8 -> -7]
[(1,4)(2,3) : -7 -> -8]
[(1,4)(2,3) : -7 -> -7]
gap> dcrd8 := DoubleCosetRepresentatives( Gd8, Ud8, Ud8 );
[ [() : -9 -> -9], [(1,4,3,2) : -9 -> -9], [() : -9 -> -8], [() : -8 -> -9], 
  [() : -8 -> -8], [(2,4) : -8 -> -8] ]
]]>
</Example>
</Section>


<Section Label="sec-conj">
<Heading>Conjugation</Heading>

<Index>\^<Subkey>for arrows</Subkey></Index>
<ManSection>
   <Oper Name="\^"
         Arg="e1, e" />
<Description>
Conjugation by an arrow <M>e = (c : p \to q)</M> 
is the groupoid inner automorphism 
(see section <Ref Sect="sec-autos"/>) defined as follows. 
There are two cases to consider. 
In the case <M>p \neq q</M>, 
<List>
<Item>
objects <M>p,q</M> are interchanged, and the remaining objects are fixed; 
</Item>
<Item> 
loops at <M>p,q</M>: <M>(b: p \to p) \mapsto (b^c : q \to q)</M> 
and    <M>(b: q \to q) \mapsto (b^{c^{-1}} : p \to p)</M>; 
</Item> 
<Item>
arrows between <M>p</M> and <M>q</M>: 
<M>(b : p \to q) \mapsto (c^{-1}bc^{-1} : q \to p)</M> 
and <M>(b : q \to p) \mapsto (cbc : p \to q)</M>; 
</Item>
<Item>
costars at <M>p,q</M>: 
<M>(b : r \to p) \mapsto (bc : r \to q)</M> 
and <M>(b : r \to q) \mapsto (bc^{-1} : r \to p)</M>; 
</Item>
<Item>
stars at <M>p,q</M>: 
<M>(b : p \to r) \mapsto (c^{-1}b :  \to q)</M> 
and <M>(b : q \to r) \mapsto (cb : p \to r)</M>; 
</Item>
<Item>
the remaining arrows are unchanged. 
</Item> 
</List>
<P/>
In the case <M>p=q</M>,
<List>
<Item> all the objects are fixed; 
</Item>
<Item> loops at <M>p</M> are conjugated by <M>c</M>, so 
<M>(b : p \to p) \mapsto (b^c : p \to p)</M>; 
</Item>
<Item> the rest of the costar and star at <M>p</M> are permuted, 
<Display>
(b : r \to p) \mapsto (bc : r \to p) 
\quad\mbox{and}\quad (b : p \to r) \mapsto (c^{-1}b : p \to r); 
</Display>
</Item>
<Item> the remaining arrows are unchanged. 
</Item>
</List>
<P/>
The details of this construction may be found in 
section 3.2 of <Cite Key="AlWe"/>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> x := Arrow( Gd8, (1,3), -9, -9 );; 
gap> y := Arrow( Gd8, (1,2,3,4), -8, -9 );; 
gap> z := Arrow( Gd8, (1,2)(3,4), -9, -7 );; 
gap> w := Arrow( Gd8, (1,2,3,4), -7, -8 );; 
gap> ##  conjugation with elements x, y, and z in Gd8: 
gap> x^y;
[(2,4) : -8 -> -8]
gap> x^z;
[(2,4) : -7 -> -7]
gap> y^x;
[() : -8 -> -9]
gap> y^z;
[(2,4) : -8 -> -7]
gap> z^x;
[(1,4,3,2) : -9 -> -7]
gap> z^y;
[(2,4) : -8 -> -7]
gap> w^z
[(1,3) : -9 -> -8]
]]>
</Example>

<Index>\^<Subkey>for groupoids</Subkey></Index>
<ManSection Label="subsec-conjgpd">
   <Oper Name="ConjugateGroupoid"
         Arg="gpd, e" />
<Description>
When <M>H</M> is a subgroupoid of a groupoid <M>G</M> and <M>a</M> 
is an arrow of <M>G</M>, then the conjugate of <M>H</M> by <M>a</M> 
is the subgroupoid generated by the conjugates of the generators of <M>H</M>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Kd8 := SubgroupoidWithRays( Gs4, d8, [(),(1,2),(2,3),(3,4),(1,4)] );
single piece groupoid with rays: < d8, [ -15 .. -11 ], 
[ (), (1,2), (2,3), (3,4), (1,4) ] >
gap> u := Arrow( Gs4, (1,2,3), -15, -14 );
[(1,2,3) : -15 -> -14]
gap> ConjugateGroupoid( Kd8, u );                                        
single piece groupoid with rays: < Group( [ (1,3,2,4), (1,2) ] ), 
[ -15, -14, -13, -12, -11 ], [ (), (1,2), (), (2,4,3), (1,4)(2,3) ] >
]]>
</Example>
</Section>

<Section Label="sec-gpd-isos">
<Heading>Groupoids formed using isomorphisms</Heading>

Here we describe an alternative way of constructing a connected groupoid. 
This section  has been introduced in version 1.66 of the package, 
and so should be considered very experimental, and liable to change. 
<P/> 
Object groups in a connected groupoid are isomorphic, 
so we may use a collection of isomorphisms to form a groupoid. 
Let <M>G_1,G_2,\ldots,G_n</M> be isomorphic groups and, 
for <M>2 \leqslant i \leqslant n</M>, 
let <M>\mu_i : G_1 \to G_i</M> be isomorphisms. 
Then <M>\mu_{ij} = \mu_i^{-1}*\mu_j</M> is an isomorphism 
from <M>G_i</M> to <M>G_j</M>. 
If we take <M>\{u_1,\ldots,u_n\}</M> to be our set of objects, 
with <M>G_i</M> the object group at <M>u_i</M>, 
we may consider the arrows in the groupoid to have the form 
<M>[[g_i,g_j] : u_i \to u_j]</M> 
where <M>g_i \in G_i</M> and <M>g_j = \mu_{ij}(g_i) \in G_j</M>. 
The product of <M>[[g_i,g_j] : u_i \to u_j]</M> 
and <M>[[g'_j,g_k] : u_j \to u_k]</M> 
is <M>[[\mu_{ij}^{-1}(g_jg'_j), \mu_{jk}(g_jg'_j)] : u_i \to u_k]</M>. 
<P/>
<ManSection>
   <Oper Name="GroupoidByIsomorphisms"
         Arg="gp, obs, isos" />
   <Prop Name="IsGroupoidByIsomorphisms"
         Arg="gpd" />
<Description>
The operation <C>GroupoidByIsomorphisms</C> 
takes a group <C>G1</C> as root group; a set of <M>n</M> objects; 
and a set of <M>n</M> isomorphisms from the root group, 
where the first isomorphism should be the identity mapping on <C>G1</C>. 
The output is a single piece groupoid of type <C>IsGroupoidByIsomorphisms</C>. 
Its rays have the form <C>[One(G1),One(Gi)]</C> 
where <C>Gi</C> is the image of the <M>i</M>-th isomorphism. 
<P/>
In the example we first take three permutation groups isomorphic 
to the symmetric group <M>S_3</M>. 
There follows an isomorphic groupoid whose object groups are 
a permutation group; a pc-group and an fp-group. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> s3a := Group( (1,2), (2,3) );; 
gap> s3b := Group( (4,6,8)(5,7,9), (4,9)(5,8)(6,7) );;
gap> s3c := Group( (4,6,8)(5,7,9), (5,9)(6,8) );;
gap> SetName( s3a, "s3a" );
gap> ida := IdentityMapping( s3a );; 
gap> isoab := IsomorphismGroups( s3a, s3b );; 
gap> isoac := IsomorphismGroups( s3a, s3c );;
gap> isos1 := [ ida, isoab, isoac ];; 
gap> G1 := GroupoidByIsomorphisms( s3a, [-3,-2,-1], isos1 );; 
gap> gens1 := GeneratorsOfGroupoid( G1 );                    
[ [[ (1,2), (1,2) ] : -3 -> -3], [[ (2,3), (2,3) ] : -3 -> -3], 
  [[ (), () ] : -3 -> -2], [[ (), () ] : -3 -> -1] ]
gap> x1 := ImageElm( isos1[2], (1,2) );;
gap> a1 := Arrow( G1, [ (1,2), x1 ], -3, -2 );
[[ (1,2), (4,5)(6,9)(7,8) ] : -3 -> -2]
gap> a1^-1;
[[ (4,5)(6,9)(7,8), (1,2) ] : -2 -> -3]
gap> y1 := ImageElm( isos1[2], (2,3) );;
gap> z1 := ImageElm( isos1[3], (2,3) );;
gap> b1 := Arrow( G1, [ y1, z1 ], -2, -1 );
[[ (4,9)(5,8)(6,7), (5,9)(6,8) ] : -2 -> -1]
gap> c1 := a1*b1;
[[ (1,3,2), (4,8,6)(5,9,7) ] : -3 -> -1]

gap> isopc := IsomorphismPcGroup( s3a );; 
gap> s3p := Image( isopc );;
gap> f2 := FreeGroup( 2 );; 
gap> s3f := f2/[ f2.1^3, f2.2^2, (f2.1*f2.2)^2 ];; 
gap> isofp := GroupHomomorphismByImages(s3a,s3f,[(1,2,3),(2,3)],[s3f.1,s3f.2]);;
gap> isos2 := [ ida, isopc, isofp ];;
gap> G2 := GroupoidByIsomorphisms( s3a, [-7,-6,-5], isos2 );; 
gap> gens2 := GeneratorsOfGroupoid( G2 );
[ [[ (1,2), (1,2) ] : -7 -> -7], [[ (2,3), (2,3) ] : -7 -> -7], 
  [[ (), <identity> of ... ] : -7 -> -6], [[ (), <identity ...> ] : -7 -> -5] 
 ]
gap> x2 := ImageElm( isos2[2], (1,2) );;
gap> a2 := Arrow( G2, [ (1,2), x2 ], -7, -6 );
[[ (1,2), f1*f2 ] : -7 -> -6]
gap> a2^-1;
[[ f1*f2, (1,2) ] : -6 -> -7]
gap> y2 := ImageElm( isos2[2], (2,3) );;
gap> z2 := ImageElm( isos2[3], (2,3) );;
gap> b2 := Arrow( G2, [ y2, z2 ], -6, -5 );
[[ f1, f2^-1 ] : -6 -> -5]
gap> c2 := a2*b2; 
[[ (1,3,2), f1^2 ] : -7 -> -5]
]]>
</Example>

</Section> 


<Section Label="sec-mon-gpd">
<Heading>Groupoids whose objects form a monoid</Heading>

Let <M>M</M> be a monoid with <M>G</M> its maximal subgroup. 
We may form a groupoid with the elements of <M>M</M> as its objects 
and with arrows <M>t \to t*g</M> for all <M>t \in M</M> and <M>g \in G</M>. 
<P/> 
This construction is used in the <Package>XMod</Package> package 
to construct the group-groupoid which corresponds to a crossed module 
or cat2-group. 
<P/>
<ManSection>
   <Oper Name="SinglePieceGroupoidWithRays"
         Arg="gp, obs, rays" />
<Description>
When <M>M</M> is a group, <M>G=M</M> and the groupoid so constructed 
is a single piece which represents the regular representation of <M>G</M>. 
The ray from <M>1</M> to <M>g</M> is just <M>g</M> since <M>1*g=g</M>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> d8 := Group( (1,2,3,4), (1,3) );; 
gap> ed8 := Elements( d8 );; 
gap> rd8 := SinglePieceGroupoidWithRays( d8, ed8, ed8 );
single piece groupoid with rays: < Group( [ (1,2,3,4), (1,3) ] ), 
[ (), (2,4), (1,2)(3,4), (1,2,3,4), (1,3), (1,3)(2,4), (1,4,3,2), (1,4)(2,3) 
 ], [ (), (2,4), (1,2)(3,4), (1,2,3,4), (1,3), (1,3)(2,4), (1,4,3,2), 
  (1,4)(2,3) ] >
gap> Display( Homset( rd8, (2,4), (1,3) ) );
[(1,3)(2,4) : (2,4) -> (1,3)]
[(1,3) : (2,4) -> (1,3)]
[() : (2,4) -> (1,3)]
[(2,4) : (2,4) -> (1,3)]
[(1,4,3,2) : (2,4) -> (1,3)]
[(1,4)(2,3) : (2,4) -> (1,3)]
[(1,2,3,4) : (2,4) -> (1,3)]
[(1,2)(3,4) : (2,4) -> (1,3)]
]]>
</Example>

<ManSection>
   <Oper Name="RightActionGroupoid"
         Arg="mon" />
   <Prop Name="IsGroupoidWithMonoidObjects"
         Arg="gpd" />
<Description>
When <M>M</M> is a monoid, rather than a group, this construction produces 
several components. 
One of these has as objects the elements of the group <M>G</M>. 
<P/> 
When <M>M</M> <E>is</E> a group, this operation gives the same result as 
<C>SinglePieceGroupoidWithRays</C>. 
<P/>
As a simple example we take a monoid <M>M</M> generated by two transformations  
of degree <M>4</M>. 
The groupoid has <M>8</M> components, 
of which <M>3</M> have a single object and group <M>C_2</M>, 
while <M>5</M> have two objects and trivial group. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> t := Transformation( [1,1,2,3] );;  u := Transformation( [1,2,4,3] );;
gap> M := Monoid( t, u );;
gap> rag := RightActionGroupoid( M );
groupoid with 8 pieces:
1:  single piece groupoid with rays: < Group( 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] ), 
[ Transformation( [ 1, 1, 1, 1 ] ) ], [ IdentityTransformation ] >
2:  single piece groupoid with rays: < Group( 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] ), 
[ Transformation( [ 1, 1, 1, 2 ] ) ], [ IdentityTransformation ] >
3:  single piece groupoid with rays: < Group( [ IdentityTransformation ] ), 
[ Transformation( [ 1, 1, 1, 3 ] ), Transformation( [ 1, 1, 1 ] ) ], 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] >
4:  single piece groupoid with rays: < Group( 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] ), 
[ Transformation( [ 1, 1, 2, 1 ] ) ], [ IdentityTransformation ] >
5:  single piece groupoid with rays: < Group( [ IdentityTransformation ] ), 
[ Transformation( [ 1, 1, 2, 3 ] ), Transformation( [ 1, 1, 2 ] ) ], 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] >
6:  single piece groupoid with rays: < Group( [ IdentityTransformation ] ), 
[ Transformation( [ 1, 1, 3, 1 ] ), Transformation( [ 1, 1, 4, 1 ] ) ], 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] >
7:  single piece groupoid with rays: < Group( [ IdentityTransformation ] ), 
[ Transformation( [ 1, 1, 3, 2 ] ), Transformation( [ 1, 1, 4, 2 ] ) ], 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] >
8:  single piece groupoid with rays: < Group( [ IdentityTransformation ] ), 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ], 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] >
gap> IsGroupoidWithMonoidObjects( rag );
true
gap> orag := ObjectList( rag );;
gap> hs := Homset( rag, orag[3], orag[4] );;  
gap> Display( hs );                  
<homset Transformation( [ 1, 1, 1, 3 ] ) -> Transformation( [ 1, 1, 1 ] )
  with elements:
[Transformation( [ 1, 2, 4, 3 ] ) : Transformation( [ 1, 1, 1, 3 ] ) -> 
Transformation( [ 1, 1, 1 ] )]
]]>
</Example>

</Section>

</Chapter>

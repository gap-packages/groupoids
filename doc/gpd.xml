<!-- ------------------------------------------------------------------- -->
<!--                                                                     -->
<!--  gpd.xml          groupoids documentation            Chris Wensley  -->
<!--                                                       & Emma Moore  -->
<!--  Copyright (C) 2000-2017, Emma Moore and Chris Wensley,             --> 
<!--  School of Computer Science, Bangor University, U.K.                --> 
<!--                                                                     -->
<!-- ------------------------------------------------------------------- -->

<?xml version="1.0" encoding="UTF-8"?>

<Chapter Label="chap-gpd">
<Heading>Groupoids</Heading>

A <E>groupoid</E> is a (mathematical) category in which every element
is invertible. 
It consists of a set of <E>pieces</E>, 
each of which is a connected groupoid. 
The usual terminology is `connected component', but in &GAP; `component' 
is used for `record component', so we use the term <E>single piece</E>.  
<P/>
The simplest form for a <E>single piece groupoid</E> 
is the direct product of a group and a complete digraph,
and so is determined by a set of <E>objects</E> <C>obs</C> <M>= \Omega</M> 
(the least of which is the <E>root object</E>), 
and a <E>root group</E> <C>grp</C> <M>= G</M>. 
Then the elements of the groupoid are <E>arrows</E> <M>g : o_1 \to o_2</M>, 
stored as triples <C>[g,o1,o2]</C>, where <M>g \in G</M> 
and <M>o_1,o_2 \in \Omega</M>.  
The objects will generally be chosen to be consecutive negative integers, 
but any suitable ordered set is acceptable, 
and `consecutive' is not a requirement.
The root group will usually be taken to be a permutation group,
but pc-groups, fp-groups and matrix groups are also supported. 
<P/>
A <E>group</E> may be considered as a single piece groupoid with one object.
<P/>
A <E>groupoid</E> is a set of one or more single piece groupoids, 
its <E>pieces</E>, and is represented as <C>IsGroupoidRep</C>, 
with attribute <C>PiecesOfGroupoid</C>.
<P/>
A groupoid is <E>homogeneous</E> if it has two of more isomorphic pieces, 
with identical groups. 
The special case of <E>homogeneous, discrete</E> groupoids, 
where each piece has a single object, is given its own representation. 
These are used in the <Package>XMod</Package> package 
as the source of a crossed modules of groupoids. 
<P/> 
For the definitions of the standard properties of groupoids
we refer to R. Brown's book ``Topology'' <Cite Key="BrTop" />, 
recently revised and reissued as ``Topology and Groupoids'' 
<Cite Key="BrTopGpd" />.


<Section Label="sec-gpds">
<Heading>Groupoids: their properties and attributes</Heading>

<ManSection>
   <Oper Name="SinglePieceGroupoid"
         Arg="grp, obs" />
   <Func Name="Groupoid"
         Arg="args" />
   <Oper Name="DomainWithSingleObject"
         Arg="gp, obj" />
<Description>
The simplest construction of a groupoid 
is as the direct product of a group and a complete digraph. 
Such a groupoid will be called a <Index Key="standard groupoid"> 
standard groupoid</Index> <E>standard groupoid</E>. 
Many subgroupoids of such a groupoid do not have this simple form, 
and will be considered in section <Ref Sect="sec-subgpds"/>. 
The global function <C>Groupoid</C> will normally find the appropriate 
constructor to call, the options being:
<List>
<Item>
the object group, a set of objects;
</Item>
<Item>
a group being converted to a groupoid, a single object; 
</Item>
<Item>
a list of groupoids which have already been constructed 
(see <Ref Subsect="sec-union" />). 
</Item>
</List>
<P/>
Methods for <C>ViewObj</C>, <C>PrintObj</C> and <C>Display</C> are
provided for groupoids and the other types of object in this package.
Users are advised to supply names for all the groups and groupoids 
they construct.
<P/> 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> s4 := Group( (1,2,3,4), (3,4) );; 
gap> d8 := Subgroup( s4, [ (1,2,3,4), (1,3) ] );;
gap> SetName( s4, "s4" );  SetName( d8, "d8" ); 
gap> Gs4 := SinglePieceGroupoid( s4, [-15 .. -11] ); 
single piece groupoid: < s4, [ -15 .. -11 ] >
gap> Gd8 := Groupoid( d8, [-9,-8,-7] );
single piece groupoid: < d8, [ -9, -8, -7 ] >
gap> c6 := Group( (5,6,7)(8,9) );;
gap> SetName( c6, "c6" );
gap> Gc6 := DomainWithSingleObject( c6, -6 );
single piece groupoid: < c6, [ -6 ] >
gap> SetName( Gs4, "Gs4" );  SetName( Gd8, "Gd8" );  SetName( Gc6, "Gc6" );  
]]>
</Example>

<ManSection>
   <Attr Name="ObjectList"
         Arg="gpd" />
   <Attr Name="RootObject"
         Arg="gpd" />
   <Attr Name="RootGroup"
         Arg="gpd" />
   <Oper Name="ObjectGroup"
         Arg="gpd, obj" />
<Description>
The <C>ObjectList</C> of a groupoid is the sorted list of objects. 
The <C>RootObject</C> in a single-piece groupoid 
is the object with least label. 
A <E>loop</E> is an arrow of the form <M>g : o \to o</M>, 
and the loops at a particular object <M>o</M> form a group, 
the <C>ObjectGroup</C> at <M>o</M>. 
The <C>RootGroup</C> is the <C>ObjectGroup</C> at the <C>RootObject</C>. 
<P/> 
In the example the groupoids <C>Gf2c6</C> and <C>Gabc</C> show that 
the objects need not be integers.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> ObjectList( Gs4 );    
[ -15 .. -11 ]
gap> [ RootObject( Gd8 ), RootGroup( Gc6 ), ObjectGroup( Gs4, -11 ) ];
[ -9, c6, s4 ]
gap> f2 := FreeGroup(2);;
gap> Gf2c6 := Groupoid( c6, GeneratorsOfGroup(f2) );
single piece groupoid: < c6, [ f1, f2 ] >
gap> Arrow( Gf2c6, (5,7,6), f2.1, f2.2 );
[(5,7,6) : f1 -> f2]
gap> Gabc := Groupoid( d8, [ "a", "b", "c" ] );
single piece groupoid: < d8, [ "a", "b", "c" ] >
gap> Arrow( Gabc, (2,4), "c", "b" );
[(2,4) : c -> b]
]]>
</Example>

<ManSection>
   <Prop Name="IsPermGroupoid"
         Arg="gpd" />
   <Prop Name="IsPcGroupoid"
         Arg="gpd" />
   <Prop Name="IsFpGroupoid"
         Arg="gpd" />
   <Prop Name="IsMatrixGroupoid"
         Arg="gpd" />
   <Prop Name="IsFreeGroupoid"
         Arg="gpd" />
<Description>
A groupoid is a permutation groupoid if all its pieces have 
permutation groups.
Most of the examples in this chapter are permutation groupoids,
but in principle any type of group known to &GAP; may be used. 
<P/>
In the following example <C>Gf2</C> is an fp-groupoid and also a free groupoid, 
<C>Gq8</C> is a pc-groupoid, and <C>Ggl43</C> is a matrix groupoid. 
See section <Ref Sect="sec-mxreps"/> for matrix representations of groupoids. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> f2 := FreeGroup( 2 );;
gap> Gf2 := Groupoid( f2, -22 );;
gap> SetName( f2, "f2" );  SetName( Gf2, "Gf2" ); 
gap> q8 := SmallGroup( 8, 4 );;
gap> Gq8 := Groupoid( q8, [ -28, -27 ] );;
gap> SetName( q8, "q8" );  SetName( Gq8, "Gq8" );
gap> gl43 := SpecialLinearGroup( 4, 3 );;
gap> Ggl43 := SinglePieceGroupoid( gl43, [ -35..-31 ] );;
gap> SetName( gl43, "gl43" );  SetName( Ggl43, "Ggl43" );
gap> [ IsMatrixGroupoid( Ggl43 ), IsFpGroupoid( Gf2 ), IsFreeGroupoid( Gf2 ), 
>      IsPcGroupoid( Gq8 ), IsPermGroupoid( Gs4 ) ]; 
[ true, true, true, true, true ]
]]>
</Example>

<ManSection Label="sec-union">
   <Oper Name="UnionOfPieces" 
         Arg="pieces" />
   <Attr Name="Pieces"
         Arg="gpd" />
   <Attr Name="Size"
         Arg="gpd" />
   <Oper Name="ReplaceOnePieceInUnion" 
         Arg="U, old_piece, new_piece" />
<Description>
When a groupoid consists of two or more pieces, 
we require their object lists to be disjoint. 
The operation <C>UnionOfPieces</C> and the attribute <C>Pieces</C>,  
introduced in section <Ref Sect="sec-pieces"/>, are also used for groupoids. 
The pieces are sorted by the least object in their object lists. 
The <Index Key="ObjectList" Subkey="for groupoids"> <C>ObjectList</C> </Index> 
<C>ObjectList</C> is the sorted concatenation of the objects in the pieces.
<P/>
The <C>Size</C> of a groupoid is the number of its arrows. 
For a single piece groupoid, this is the product of the size of the group 
with the square of the number of objects. 
For a non-connected groupoid, the size is the sum of the sizes of its pieces. 
<P/>
One of the pieces in a groupoid may be replaced by an alternative piece 
using the operation <C>ReplaceOnePieceInUnion</C>. 
The <E>old_piece</E> may be either the <E>position</E> of the piece to be replaced, or one of the pieces in <C>U</C>.  
The objects in the new piece may or may not overlap the objects 
in the piece being removed -- 
we just require that the object lists in the new union are disjoint. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> U3 := UnionOfPieces( [ Gc6, Gd8, Gs4 ] );;
gap> Display( U3 );
groupoid with 3 pieces:
< objects: [ -15 .. -11 ]
    group: s4 = <[ (1,2,3,4), (3,4) ]> >
< objects: [ -9, -8, -7 ]
    group: d8 = <[ (1,2,3,4), (1,3) ]> >
< objects: [ -6 ]
    group: c6 = <[ (5,6,7)(8,9) ]> >
gap> Pieces( U3 );
[ Gs4, Gd8, Gc6 ]
gap> ObjectList( U3 );
[ -15, -14, -13, -12, -11, -9, -8, -7, -6 ]
gap> U2 := Groupoid( [ Gf2, Gq8 ] );;
gap> [ Size(Gs4), Size(Gd8), Size(Gc6), Size(U3) ];
[ 600, 72, 6, 678 ]
gap> [ Size(Gf2), Size(Gq8), Size(U2) ];           
[ infinity, 32, infinity ]
gap> U5 := UnionOfPieces( [ U3, U2 ] );
groupoid with 5 pieces:
[ Gq8, Gf2, Gs4, Gd8, Gc6 ]
gap> Display( U5 );
groupoid with 5 pieces:
< objects: [ -28, -27 ]
    group: q8 = <[ f1, f2, f3 ]> >
< objects: [ -22 ]
    group: f2 = <[ f1, f2 ]> >
< objects: [ -15 .. -11 ]
    group: s4 = <[ (1,2,3,4), (3,4) ]> >
< objects: [ -9, -8, -7 ]
    group: d8 = <[ (1,2,3,4), (1,3) ]> >
< objects: [ -6 ]
    group: c6 = <[ (5,6,7)(8,9) ]> >
gap> V5 := ReplaceOnePieceInUnion( U5, 3, Ggl43 ); 
groupoid with 5 pieces:
[ Ggl43, Gq8, Gf2, Gd8, Gc6 ]
gap> ObjectList( V5 );             
[ -35, -34, -33, -32, -31, -28, -27, -22, -9, -8, -7, -6 ]
gap> U5 = V5;
false
gap> W5 := ReplaceOnePieceInUnion( V5, Gc6, Gs4 ); 
groupoid with 5 pieces:
[ Ggl43, Gq8, Gf2, Gs4, Gd8 ]
gap> ObjectList( W5 );
[ -35, -34, -33, -32, -31, -28, -27, -22, -15, -14, -13, -12, -11, -9, -8, -7 
 ]
]]>
</Example>

<ManSection>
   <Oper Name="HomogeneousGroupoid" 
         Arg="gpd, oblist" />
   <Oper Name="HomogeneousDiscreteGroupoid" 
         Arg="gp, obs" />
<Description>
Special functions are provided for the case where a groupoid has 
more than one connected component, and when these components are identical 
except for their object sets. 
Such groupoids are said to be <E>homogeneous</E>. 
<P/>
The operation <C>HomogeneousGroupoid</C> is used when the components 
each contain more than one object. 
The arguments consist of a single piece groupoid <C>gpd</C> 
and a list of lists of objects <C>oblist</C>, 
each of whose lists has the same length as the object list 
<C>obs</C> of <C>gpd</C>. 
Note that <C>gpd</C> is <E>not</E> included as one of the pieces in the output 
unless <C>obs</C> is included as one of the lists in <C>oblist</C>. 
<P/>
The operation <C>HomogeneousDiscreteGroupoid</C> is used 
when the components each have a single object. 
In this case the first argument is just a group -- 
the root group for each component. 
These groupoids are used in the <Package>XMod</Package> package 
as the source of many crossed modules of groupoids. 
<P/>
Both types of groupoid have the property 
<Index Key="IsHomogeneousDomainWithObjects">  <C>IsHomogeneousDomainWithObjects</C> </Index> 
<C>IsHomogeneousDomainWithObjects</C>. 
In the latter case a separate representation 
<Index Key="IsHomogeneousDomainWithObjectsRep">  <C>IsHomogeneousDiscreteGroupoidRep</C> </Index> 
<C>IsHomogeneousDiscreteGroupoidRep</C> is used. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Hd8 := HomogeneousGroupoid( Gd8, [ [-12,-11,-10], [-16,-15,-14] ] );
homogeneous groupoid with 2 pieces:
1:  single piece groupoid: < d8, [ -16, -15, -14 ] >
2:  single piece groupoid: < d8, [ -12, -11, -10 ] >
gap> Size(Hd8);   ## 8x3x3 + 8x3x3
144
gap> IsHomogeneousDomainWithObjects( Hd8 );               
true
gap> Hc6 := HomogeneousDiscreteGroupoid( c6, [-7..-4] ); 
homogeneous, discrete groupoid: < c6, [ -7 .. -4 ] >
gap> Size(Hc6);   ## 6x4
24
gap> RepresentationsOfObject(Gd8);
[ "IsComponentObjectRep", "IsAttributeStoringRep", "IsMWOSinglePieceRep" ]
gap> RepresentationsOfObject(Hd8);
[ "IsComponentObjectRep", "IsAttributeStoringRep", "IsPiecesRep" ]
gap> RepresentationsOfObject(Hc6);
[ "IsComponentObjectRep", "IsAttributeStoringRep", 
  "IsHomogeneousDiscreteGroupoidRep" ]
gap> ktpo := KnownTruePropertiesOfObject(Hc6);; 
gap> ans := 
> [ "CanEasilyCompareElements", "CanEasilySortElements", 
>   "IsDuplicateFree", "IsAssociative", "IsCommutative", 
>   "IsDiscreteDomainWithObjects", "IsHomogeneousDomainWithObjects" ];;
gap> ForAll( ans, a -> ( a in ktpo ) ); 
true
]]>
</Example>

<ManSection>
   <Oper Name="DirectProductOp" 
         Arg="list, gpd" />
   <Oper Name="Projection" 
         Arg="gpd, pos" />
   <Oper Name="Embedding" 
         Arg="gpd, pos" />
<Description>
The direct product of groupoids <M>G,H</M> has as group the direct product 
of the groups in <M>G</M> and <M>H</M> and as object list the cartesian 
product of their object lists.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> prod := DirectProductOp( [Gd8,Gc6], Gd8 );
single piece groupoid: < Group( [ (1,2,3,4), (1,3), (5,6,7)(8,9) ] ), 
[ [ -9, -6 ], [ -8, -6 ], [ -7, -6 ] ] >
gap> Projection( prod, 1 );                    
groupoid homomorphism : 
[ [ [(1,2,3,4) : [ -9, -6 ] -> [ -9, -6 ]], [(1,3) : [ -9, -6 ] -> [ -9, -6 ]]
        , [(5,6,7)(8,9) : [ -9, -6 ] -> [ -9, -6 ]], 
      [() : [ -9, -6 ] -> [ -8, -6 ]], [() : [ -9, -6 ] -> [ -7, -6 ]] ], 
  [ [(1,2,3,4) : -9 -> -9], [(1,3) : -9 -> -9], [() : -9 -> -9], 
      [() : -9 -> -8], [() : -9 -> -7] ] ]
gap> Embedding(prod,2);                        
groupoid homomorphism : 
[ [ [(5,6,7)(8,9) : -6 -> -6] ], 
  [ [(5,6,7)(8,9) : [ -9, -6 ] -> [ -9, -6 ]] ] ]
gap> DirectProductInfo( prod );
rec( embeddings := [ , groupoid homomorphism : 
        [ [ [(5,6,7)(8,9) : -6 -> -6] ], 
          [ [(5,6,7)(8,9) : [ -9, -6 ] -> [ -9, -6 ]] ] ] ], first := Gd8, 
  groupoids := [ Gd8, Gc6 ], groups := [ d8, c6 ], 
  objectlists := [ [ -9, -8, -7 ], [ -6 ] ], 
  projections := [ groupoid homomorphism : 
        [ [ [(1,2,3,4) : [ -9, -6 ] -> [ -9, -6 ]], 
              [(1,3) : [ -9, -6 ] -> [ -9, -6 ]], 
              [(5,6,7)(8,9) : [ -9, -6 ] -> [ -9, -6 ]], 
              [() : [ -9, -6 ] -> [ -8, -6 ]], 
              [() : [ -9, -6 ] -> [ -7, -6 ]] ], 
          [ [(1,2,3,4) : -9 -> -9], [(1,3) : -9 -> -9], [() : -9 -> -9], 
              [() : -9 -> -8], [() : -9 -> -7] ] ] ] )
]]>
</Example>

</Section>


<Section Label="sec-elements">
<Heading>Groupoid elements; stars; costars; homsets</Heading>

<ManSection>
   <Oper Name="GroupoidElement"
         Arg="gpd, elt, tail, head" />
   <Oper Name="ElementOfArrow"
         Arg="elt" />
   <Oper Name="TailOfArrow"
         Arg="elt" />
   <Oper Name="HeadOfArrow"
         Arg="elt" />
<Description> 
<Index Key="Arrow" Subkey="for groupoid elements"> <C>Arrow</C> </Index>
The operation <C>GroupoidElement</C> is a synonym for the operation 
<C>Arrow</C>, as described in subsection <Ref Sect="man-arrow"/>. 
To recapitulate, an arrow <C>e</C> consists of 
a group element, <C>ElementOfArrow(e)</C>; 
the tail (source) object, <C>TailOfArrow(e)</C>;
and the head (target) object, <C>HeadOfArrow(e)</C>.
Arrows have a <E>partial composition</E>: 
two arrows may be multiplied when the head of the first 
coincides with the tail of the second. 
If an attempt is made to multiply arrows where this condition does not hold, 
then the value <C>fail</C> is returned. 
<P/>
</Description>
</ManSection>
<Index>* for groupoid elements</Index>
<Example>
<![CDATA[
gap> e1 := GroupoidElement( Gd8, (1,2,3,4), -9, -8 );
[(1,2,3,4) : -9 -> -8]
gap> e2 := Arrow( Gd8, (1,3), -8, -7 );
[(1,3) : -8 -> -7]
gap> Print( [ ElementOfArrow(e1), TailOfArrow(e1), HeadOfArrow(e1) ], "\n" );
[ (1,2,3,4), -9, -8 ]
gap> prod := e1*e2;
[(1,2)(3,4) : -9 -> -7]
gap> e2*e1;
fail
gap> e3 := Arrow( Gd8, (2,4), -7, -9 );;
gap> loop := prod*e3;
[(1,4,3,2) : -9 -> -9]
gap> loop^2;
[(1,3)(2,4) : -9 -> -9]
]]>
</Example>

<ManSection>
   <Oper Name="IdentityArrow"
         Arg="gpd, obj" />
<Description>
The identity arrow <M>1_o</M> of <M>G</M> at object <M>o</M> 
is <M>(e:o \to o)</M> where <M>e</M> is the identity element in the 
object group. 
The <Index Key="inverse arrow"> inverse arrow </Index>
<E>inverse arrow</E> <M>e^{-1}</M> of <M>e = (c : p \to q)</M> is 
<M>(c^{-1} : q \to p)</M>, 
so that <M>e*e^{-1}=1_p</M> and <M>e^{-1}*e = 1_q</M>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> i8 := IdentityArrow( Gd8, -8 );
[() : -8 -> -8]
gap> [ e1*i8, i8*e1, e1^-1]; 
[ [(1,2,3,4) : -9 -> -8], fail, [(1,4,3,2) : -8 -> -9] ]
]]>
</Example>

<ManSection>
   <Attr Name="Order"
         Arg="arr" />
<Description>
A groupoid element is a <Index Key="loop"> loop </Index> <E>loop</E> 
when the tail and head coincide. 
In this case the order of the element is defined to be 
the order of its group element.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> i8; Order(i8);
[() : -8 -> -8]
1
gap> loop; Order(loop);
[(1,4,3,2) : -9 -> -9]
4
]]>
</Example>

<ManSection>
   <Oper Name="ObjectStar"
         Arg="gpd, obj" />
   <Oper Name="ObjectCostar"
         Arg="gpd, obj" />
   <Oper Name="Homset"
         Arg="gpd, tail, head" />
<Description>
The <E>star</E> at <C>obj</C> is the set of arrows 
which have <C>obj</C> as tail,
while the <E>costar</E> is the set of arrows which have <C>obj</C> as head.
The <E>homset</E> from <C>obj1</C> to <C>obj2</C>
is the set of arrows with the specified tail and head, 
and so is bijective with the elements of the object groups. 
Thus every star and every costar is a union of homsets. 
The identity arrow at an object is a left identity for the star 
and a right identity for the costar at that object.
<P/>
In order not to create unneccessarily long lists, 
these operations return objects of type <C>IsHomsetCosetsRep</C> 
for which an <C>Iterator</C> is provided. 
(An <C>Enumerator</C> is not yet implemented.)
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> star9 := ObjectStar( Gd8, -9 );
<star at [ -9 ] with group d8>
gap> Size( star9 ); 
24
gap> for e in star9 do
>      if ( Order( ElementOfArrow(e) ) = 4 ) then Print( e, "\n" ); fi;
>    od;
[(1,4,3,2) : -9 -> -9]
[(1,4,3,2) : -9 -> -8]
[(1,4,3,2) : -9 -> -7]
[(1,2,3,4) : -9 -> -9]
[(1,2,3,4) : -9 -> -8]
[(1,2,3,4) : -9 -> -7]
gap> costar6 := ObjectCostar( Gc6, -6 );
<costar at [ -6 ] with group c6>
gap> Size( costar6 ); 
6
gap> hsetq8 := Homset( Gq8, -28, -27 );
<homset -28 -> -27 with group q8>
gap> for e in hsetq8 do Print(e,"\n"); od;
[<identity> of ... : -28 -> -27]
[f3 : -28 -> -27]
[f2 : -28 -> -27]
[f2*f3 : -28 -> -27]
[f1 : -28 -> -27]
[f1*f3 : -28 -> -27]
[f1*f2 : -28 -> -27]
[f1*f2*f3 : -28 -> -27]
]]>
</Example>

</Section>



<Section Label="sec-subgpds">
<Heading>Subgroupoids</Heading>

<ManSection>
   <Func Name="Subgroupoid"
         Arg="args" />
   <Oper Name="SubgroupoidByPieces"
         Arg="gpd, obhoms" />
   <Oper Name="IsSubgroupoid"
         Arg="gpd, sgpd" />
   <Oper Name="IsWideSubgroupoid"
         Arg="gpd, sgpd" />
<Description>
A <E>subgroupoid</E> <M>S</M> of a groupoid <M>G</M> has as objects 
some subset of the objects of <M>G</M>.
It is <E>wide</E> in <M>G</M> if both groupoids have the same object set.
It is <E>full</E> if, for any two objects in <M>S</M>, 
the <C>Homset</C> is the same as that in <M>G</M>.
The arrows of <M>S</M> are a subset of those of <M>G</M>,
closed under multiplication and
with tail and head in the chosen object set.
<P/>
There are a variety of constructors for a subgroupoid of a standard groupoid, 
and the most general is the operation <C>SubgroupoidByPieces</C>. 
Its two parameters are a groupoid and a list of pieces, 
each piece being specified as a list <C>[sgp,obs]</C>,  
where <C>sgp</C> is a subgroup of the root group in that piece, 
and <C>obs</C> is a subset of the objects in that piece.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> c4 := Subgroup( d8, [ (1,2,3,4) ] );;
gap> k4 := Subgroup( d8, [ (1,2)(3,4), (1,3)(2,4) ] );;
gap> SetName( c4, "c4" );  SetName( k4, "k4" );
gap> Ud8 := Subgroupoid( Gd8, [ [ k4, [-9] ], [ c4, [-8,-7] ] ] );;
gap> SetName( Ud8, "Ud8" );
gap> Display( Ud8 );
groupoid with 2 pieces:
< objects: [ -9 ]
    group: k4 = <[ (1,2)(3,4), (1,3)(2,4) ]> >
< objects: [ -8, -7 ]
    group: c4 = <[ (1,2,3,4) ]> >
gap> [ Parent( Ud8 ), IsWide( Gd8, Ud8 ) ]; 
[ Gd8, true ]
gap> genf2b := List( GeneratorsOfGroup(f2), g -> g^2 );
[ f1^2, f2^2 ]
gap> f2b := Subgroup( f2, genf2b );;
gap> SU2 := SubgroupoidByPieces( U2, [ [q8,[-27]], [f2b,[-22]] ] );
groupoid with 2 pieces:
1:  single piece groupoid: < q8, [ -27 ] >
2:  single piece groupoid: < Group( [ f1^2, f2^2 ] ), [ -22 ] >
gap> IsWideSubgroupoid( U2, SU2 );
false
gap> IsSubgroupoid( Gf2, Groupoid( f2b, [-22] ) );
true
]]>
</Example>

<ManSection>
   <Oper Name="FullSubgroupoid"
         Arg="gpd, obs" />
   <Attr Name="FullTrivialSubgroupoid"
         Arg="gpd" />
<Description>
The <C>FullSubgroupoid</C> of a groupoid <C>gpd</C> 
on a subset <C>obs</C> of its objects 
contains all the arrows of <C>gpd</C> with tail and head in <C>obs</C>.
A <Index Key="trivial subgroupoid"> trivial subgroupoid </Index> 
<E>trivial subgroupoid</E> 
has trivial object groups, but need not be discrete.
A single piece trivial groupoid is sometimes called a 
<Index Key="tree groupoid"> tree groupoid </Index> <E>tree groupoid</E>.
(The term <Index Key="identity subgroupoid"> identity subgroupoid </Index> 
<E>identity subgroupoid</E> was used in versions up to 1.14.)  
The global function <C>Subgroupoid</C> should call the appropriate operation.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> FullSubgroupoid( U3, [-7,-6] );
groupoid with 2 pieces:
1:  single piece groupoid: < d8, [ -7 ] >
2:  single piece groupoid: < c6, [ -6 ] >
gap> FullTrivialSubgroupoid( Ud8 );
groupoid with 2 pieces:
1:  single piece groupoid: < id(k4), [ -9 ] >
2:  single piece groupoid: < id(c4), [ -8, -7 ] >
]]>
</Example>

<ManSection>
   <Oper Name="DiscreteSubgroupoid"
         Arg="gpd, sgps, obs" />
   <Attr Name="MaximalDiscreteSubgroupoid"
         Arg="gpd" />
   <Attr Name="DiscreteTrivialSubgroupoid"
         Arg="gpd" />
<Description>
A subgroupoid is <E>discrete</E> if it is a union of groups. 
The <C>MaximalDiscreteSubgroupoid</C> of <C>gpd</C> 
is the union of all the single-object full subgroupoids of <C>gpd</C>.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> DiscreteSubgroupoid( U3, [ c4, k4 ], [-9,-7] );
groupoid with 2 pieces:
1:  single piece groupoid: < c4, [ -9 ] >
2:  single piece groupoid: < k4, [ -7 ] >
gap> MaximalDiscreteSubgroupoid(U2);
groupoid with 3 pieces:
1:  single piece groupoid: < q8, [ -28 ] >
2:  single piece groupoid: < q8, [ -27 ] >
3:  single piece groupoid: < f2, [ -22 ] >
gap> DiscreteTrivialSubgroupoid( U2 );
groupoid with 3 pieces:
1:  single piece groupoid: < id(q8), [ -28 ] >
2:  single piece groupoid: < id(q8), [ -27 ] >
3:  single piece groupoid: < id(f2), [ -22 ] >
]]>
</Example>

<ManSection>
   <Oper Name="SubgroupoidWithRays"
         Arg="gpd, sgp, rays" />
   <Oper Name="RaysOfGroupoid"
         Arg="gpd" />
   <Oper Name="RayElementsOfGroupoid"
         Arg="gpd" />
<Description>
If groupoid <M>G</M> is of type <C>IsDirectProductWithCompleteDigraph</C> 
with group <M>g</M> and <M>n</M> objects, 
then a typical wide subgroupoid <M>H</M> of <M>G</M> is formed by choosing 
a subgroup <M>h</M> of <M>g</M> to be the object group 
at the root object <M>q</M>, and an arrow  
<M>r : q \to p</M> for each of the objects <M>p</M>. 
The chosen loop arrow at <M>q</M> must be the identity arrow. 
These <M>n</M> arrows are called the 
<Index Key="rays"> rays</Index> <E>rays</E> of the subgroupoid. 
The arrows in the homset from <M>p</M> to <M>p'</M> have the form 
<M>r^{-1}xr'</M> where <M>r,r'</M> are the rays from <M>q</M> 
to <M>p,p'</M> respectively, and <M>x \in h</M>. 
<P/>
The operation <C>RaysOfGroupoid</C> returns a list of arrows, 
one for each object, while the operation <C>RayElementsOfGroupoid</C> 
returns the list of group elements in these arrows. 
<P/>
In the following example we construct a subgroupoid with rays 
on three of the five objects.  It is therefore necessary to construct 
the full subgroupoid on these three objects first. 
<P/> 
Note that it is also possible to construct a subgroupoid with rays 
of a subgroupoid with rays. 
<P/>
Note also that the function <Index Key="Ancestor"> <C>Ancestor</C></Index> 
<C>Ancestor</C> provides an iteration of <C>Parent</C>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Hs4 := FullSubgroupoid( Gs4, [-14,-13,-12] );; 
gap> SetName( Hs4, "Hs4" ); 
gap> Hd8a := SubgroupoidWithRays( Hs4, d8, [(),(2,3),(3,4)] );
single piece groupoid with rays: < d8, [ -14, -13, -12 ], [ (), (2,3), (3,4) 
 ] >
gap> hs1413 := Homset( Hd8a, -14, -13 );
<homset -14 -> -13 with group d8>
gap> for e in hs1413 do  Print(e,", "); od;  Print( "\n");
[(2,3) : -14 -> -13], [(2,4,3) : -14 -> -13], [(1,2,4,3) : -14 -> -13], [
(1,2,3) : -14 -> -13], [(1,4,2) : -14 -> -13], [(1,4) : -14 -> -13], [
(1,3,4) : -14 -> -13], [(1,3,4,2) : -14 -> -13], 
gap> Hd8b := SubgroupoidWithRays( Hs4, d8, [(),(1,2,3),(1,2,4)] );
single piece groupoid with rays: < d8, [ -14, -13, -12 ], 
[ (), (1,2,3), (1,2,4) ] >
gap> Hd8a = Hd8b; 
true
gap> SetName( Hd8b, "Hd8b" ); 
gap> RayElementsOfGroupoid( Hd8b ); 
[ (), (1,2,3), (1,2,4) ]
gap> Parent( Hd8a );
Hs4
gap> Ancestor( Hd8a ); 
Gs4
gap> Fd8a := FullSubgroupoid( Hd8a, [-13,-12] );            
single piece groupoid with rays: < Group( [ (1,3,2,4), (1,2) ] ), 
[ -13, -12 ], [ (), (2,4,3) ] >
gap> Kd8a := SubgroupoidWithRays( Fd8a, k4, [ (), (1,3) ] ); 
single piece groupoid with rays: < k4, [ -13, -12 ], [ (), (1,3) ] >
]]>
</Example>

<ManSection>
   <Oper Name="SinglePieceSubgroupoidByGenerators"
         Arg="parent, gens" />
<Description>
A set of arrows generates a groupoid by taking all possible 
products and inverses.  
So far, the only implementation is for the case of loops generating a 
group at an object <M>o</M> together with a set of rays from <M>o</M>, 
where <M>o</M> is <E>not</E> the least object. 
A suitably large supergroupoid, which must be a direct product with a 
complete digraph, should be provided. 
This is the case needed for <C>ConjugateGroupoid</C> 
in section <Ref Sect="subsec-conjgpd"/>. 
Other cases will be added as time permits. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> u := Arrow( Gs4, (1,2,3), -15, -13 ); 
[(1,2,3) : -15 -> -13]
gap> gensa := GeneratorsOfGroupoid( Hd8a );
[ [(1,2,3,4) : -14 -> -14], [(1,3) : -14 -> -14], [(2,3) : -14 -> -13], 
  [(3,4) : -14 -> -12] ]
gap> imsa := List( gensa, g -> g^u ); 
[ [(1,2,3,4) : -14 -> -14], [(1,3) : -14 -> -14], [(1,3) : -14 -> -15], 
  [(3,4) : -14 -> -12] ]
gap> C := SinglePieceSubgroupoidByGenerators( Gs4, imsa ); 
single piece groupoid with rays: < Group( [ (1,4,3,2), (1,3) ] ), 
[ -15, -14, -12 ], [ (), (1,3), (1,4,3) ] >
]]>
</Example>

</Section>



<Section Label="sec-cosets">
<Heading>Left, right and double cosets</Heading>

<ManSection>
   <Oper Name="RightCoset"
         Arg="G, U, elt" />
   <Oper Name="RightCosetRepresentatives"
         Arg="G, U" />
   <Oper Name="LeftCoset"
         Arg="G, U, elt" />
   <Oper Name="LeftCosetRepresentatives"
         Arg="G, U" />
   <Oper Name="LeftCosetRepresentativesFromObject"
         Arg="G, U, obj" />
   <Oper Name="DoubleCoset"
         Arg="G, U, elt, V" />
   <Oper Name="DoubleCosetRepresentatives"
         Arg="G, U, V" />
<Description>
If <C>U</C> is a wide subgroupoid of <M>G</M>, 
the <E>right cosets</E> <M>Ug</M> of <M>U</M> in <M>G</M>
are the equivalence classes for the relation on the arrows of <M>G</M>
where  <M>g1</M> is related to <M>g2</M> if and only if <M>g2 = u*g1</M>
for some arrow <M>u</M> of <M>U</M>.
The right coset containing <M>g</M> is written <M>Ug</M>.
These right cosets partition the costars of <M>G</M> and, 
in particular, the costar <M>U1\_{o}</M> of <M>U</M> at object <M>o</M>, 
so that (unlike groups) <M>U</M> is itself a coset only when 
<M>G</M> has a single object.
<P/>
The <E>right coset representatives</E> for <M>U</M> in <M>G</M> 
form a list containing one arrow for each coset where, 
in a particular piece of <M>U</M>, 
the group element chosen is the right coset representative 
of the group of <M>U</M> in the group of <M>G</M>.
<P/>
Similarly, the <E>left cosets</E> <M>gU</M> refine the stars of <M>G</M>, 
while <E>double cosets</E> are unions of left cosets and right cosets.
The operation <C>LeftCosetRepresentativesFromObject( G, U, obj )</C> 
is used in Chapter 4, 
and returns only those representatives which have tail at <C>obj</C>. 
<P/>
As with stars and homsets, these cosets are implemented with representation 
<C>IsHomsetCosetsRep</C> and provided with an iterator.
Note that, when <M>U</M> has more than one piece, 
cosets may have differing lengths.
<P/>
In the example the representative for the right coset <C>re2</C> 
is the last one in the list <C>rcrd8</C>, namely <C>[(2,4):-8->-7]</C>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> re2 := RightCoset( Gd8, Ud8, e2 );
RightCoset(single piece groupoid: < c4, [ -8, -7 ] >,[(1,3) : -8 -> -7])
gap> for x in re2 do Print( x, "\n" ); od;
[(1,3) : -8 -> -7]
[(1,3) : -7 -> -7]
[(2,4) : -8 -> -7]
[(2,4) : -7 -> -7]
[(1,4)(2,3) : -8 -> -7]
[(1,4)(2,3) : -7 -> -7]
[(1,2)(3,4) : -8 -> -7]
[(1,2)(3,4) : -7 -> -7]
gap> rcrd8 := RightCosetRepresentatives( Gd8, Ud8 );
[ [() : -9 -> -9], [() : -9 -> -8], [() : -9 -> -7], [(2,4) : -9 -> -9],
  [(2,4) : -9 -> -8], [(2,4) : -9 -> -7], [() : -8 -> -9], [() : -8 -> -8],
  [() : -8 -> -7], [(2,4) : -8 -> -9], [(2,4) : -8 -> -8], [(2,4) : -8 -> -7]
 ]
gap> lcr7 := LeftCosetRepresentativesFromObject( Gd8, Ud8, -7 );
[ [() : -7 -> -9], [(2,4) : -7 -> -9], [() : -7 -> -8], [(2,4) : -7 -> -8] ]
]]>
</Example>
</Section>


<Section Label="sec-conj">
<Heading>Conjugation</Heading>

<Index>\^{} for arrows</Index>
<ManSection>
   <Oper Name="\^"
         Arg="e1, e" />
<Description>
Conjugation by an arrow <M>e = (c : p \to q)</M> 
is the groupoid inner automorphism 
(see section <Ref Sect="sec-autos"/>) defined as follows. 
There are two cases to consider. 
In the case <M>p \neq q</M>, 
<List>
<Item>
objects <M>p,q</M> are interchanged, and the remaining objects are fixed; 
</Item>
<Item> 
loops at <M>p,q</M>: <M>(b: p \to p) \mapsto (b^c : q \to q)</M> 
and    <M>(b: q \to q) \mapsto (b^{c^{-1}} : p \to p)</M>; 
</Item> 
<Item>
arrows between <M>p</M> and <M>q</M>: 
<M>(b : p \to q) \mapsto (c^{-1}bc^{-1} : q \to p)</M> 
and <M>(b : q \to p) \mapsto (cbc : p \to q)</M>; 
</Item>
<Item>
costars at <M>p,q</M>: 
<M>(b : r \to p) \mapsto (bc : r \to q)</M> 
and <M>(b : r \to q) \mapsto (bc^{-1} : r \to p)</M>; 
</Item>
<Item>
stars at <M>p,q</M>: 
<M>(b : p \to r) \mapsto (c^{-1}b :  \to q)</M> 
and <M>(b : q \to r) \mapsto (cb : p \to r)</M>; 
</Item>
<Item>
the remaining arrows are unchanged. 
</Item> 
</List>
<P/>
In the case <M>p=q</M>,
<List>
<Item> all the objects are fixed; 
</Item>
<Item> loops at <M>p</M> are conjugated by <M>c</M>, so 
<M>(b : p \to p) \mapsto (b^c : p \to p)</M>; 
</Item>
<Item> the rest of the costar and star at <M>p</M> are permuted, 
<Display>
(b : r \to p) \mapsto (bc : r \to p) 
\quad\mbox{and}\quad (b : p \to r) \mapsto (c^{-1}b : p \to r); 
</Display>
</Item>
<Item> the remaining arrows are unchanged. 
</Item>
</List>
<P/>
The details of this construction may be found in 
section 3.2 of <Cite Key="AlWe"/>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> x := Arrow( Gd8, (1,3), -9, -9 );; 
gap> y := Arrow( Gd8, (1,2,3,4), -8, -9 );; 
gap> z := Arrow( Gd8, (1,2)(3,4), -9, -7 );; 
gap> w := Arrow( Gd8, (1,2,3,4), -7, -8 );; 
gap> ##  conjugation with elements x, y, and z in Gd8: 
gap> x^y;
[(2,4) : -8 -> -8]
gap> x^z;
[(2,4) : -7 -> -7]
gap> y^x;
[() : -8 -> -9]
gap> y^z;
[(2,4) : -8 -> -7]
gap> z^x;
[(1,4,3,2) : -9 -> -7]
gap> z^y;
[(2,4) : -8 -> -7]
gap> w^z
[(1,3) : -9 -> -8]
]]>
</Example>

<Index>\^{} for groupoids</Index>
<ManSection Label="subsec-conjgpd">
   <Oper Name="ConjugateGroupoid"
         Arg="gpd, e" />
<Description>
When <M>H</M> is a subgroupoid of a groupoid <M>G</M> and <M>a</M> 
is an arrow of <M>G</M>, then the conjugate of <M>H</M> by <M>a</M> 
is the subgroupoid generated by the conjugates of the generators of <M>H</M>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> ConjugateGroupoid( Hd8a, u^-1 ); 
single piece groupoid with rays: < Group( [ (1,4,3,2), (1,3) ] ), 
[ -15, -14, -12 ], [ (), (1,3), (1,4,3) ] >
]]>
</Example>
</Section>

More examples of all these operations may be found in the example file 
<F>groupoids/examples/gpd.g</F>.

</Chapter>

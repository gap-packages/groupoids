<!-- ------------------------------------------------------------------- -->
<!--                                                                     -->
<!--  gpdhom.xml       groupoids documentation            Chris Wensley  -->
<!--                                                       & Emma Moore  -->
<!--  Copyright (C) 2000-2022, Emma Moore and Chris Wensley,             --> 
<!--  School of Computer Science, Bangor University, U.K.                --> 
<!--                                                                     -->
<!-- ------------------------------------------------------------------- -->

<?xml version="1.0" encoding="UTF-8"?>

<Chapter Label="chap-gpdhom">
<Heading>Homomorphisms of Groupoids</Heading>

A <E>homomorphism</E> <M>m</M> from a groupoid <M>G</M> to a groupoid <M>H</M>
consists of a map from the objects of <M>G</M> to those of <M>H</M>
together with a map from the elements of <M>G</M> to those of <M>H</M>
which is compatible with tail and head and which preserves multiplication: 
<Display>
m(g1 : o1 \to o2)*m(g2 : o2 \to o3) ~=~ m(g1*g2 : o1 \to o3).
</Display>
<P/>
Note that when a homomorphism is not injective on objects, 
the image of the source need not be a subgroupoid of the range.
A simple example of this is given by a homomorphism from the two-object,  
four-element groupoid with trivial group to the free group 
<M>\langle a \rangle</M> 
on one generator, when the image is <M>[1,a^n,a^{-n}]</M> 
for some <M>n>0</M>. 
<P/> 
A variety of homomorphism operations are available. 
<List>
<Item>
The basic construction is a homomorphism <M>\phi : G \to H</M> 
<E>from</E> a connected groupoid <M>G</M> to a connected groupoid <M>H</M>, 
constructed using <C>GroupoidHomomorphismFromSinglePiece</C>, 
(see <Ref Sect="sec-homsfrom"/>). 
</Item>
<Item> 
Since more than one connected groupoid may be mapped <E>to</E> the same range, 
we then have the operation <C>GroupoidHomomorphismToSinglePiece</C>, 
(see <Ref Sect="sec-homsto"/>). 
</Item>
<Item>
The third case arises when the range is a union of connected groupoids, 
in which case <C>HomomorphismByUnion</C> is called, 
(see <Ref Sect="sec-genhoms"/>).
</Item>
<Item> 
Fourthly, there are is an additional operation for the case where the source 
is homogeneous and discrete, <C>GroupoidHomomorphismFromHomogeneousDiscrete</C>, 
(see <Ref Sect="subsec-hom-from-disc"/>).
</Item> 
<Item>
Finally, there are special operations for inclusion mappings, 
restricted mappings, and groupoid automorphisms (see <Ref Sect="sec-autos"/>).
</Item>
</List>
<P/> 

<Section Label="sec-homsfrom">
<Heading>Homomorphisms from a connected groupoid</Heading>

<ManSection>
   <Oper Name="GroupoidHomomorphismFromSinglePiece"
         Arg="src, rng, gens, images" />
   <Func Name="GroupoidHomomorphism"
         Arg="args" />
   <Attr Name="MappingToSinglePieceData" 
         Arg="map" Label="for groupoids" /> 
<Description>
The simplest groupoid homomorphism is a mapping <M>\phi : G \to H</M> 
from a connected groupoid <M>G</M> to a connected groupoid <M>H</M>. 
There are two equivalent sets of input data which may be used. 
Both require the <C>Source</C> <M>G</M> and the <C>Range</C> <M>H</M>. 
The first then requires: 
<List>
<Item>
the set of generating arrows <C>GeneratorsOfGroupoid(G)</C>; 
</Item>
<Item>
a list of image arrows in <M>H</M>. 
</Item>
</List>
This data is stored in the attribute <C>MappingGeneratorsImages</C>. 
<P/>
The alternative input data consists of: 
<List>
<Item>
a homomorphism <C>rhom</C> from the root group of <M>G</M> 
to the group at the image object in <M>H</M>; 
</Item>
<Item>
a list <C>imobs</C> of the images of the objects of <M>G</M>;
</Item>
<Item>
a list <C>imrays</C> of the elements in the images of the rays of <M>G</M>, 
so that the image <M>\phi(r_i : o_1 \to o_i)</M> 
of the <M>i</M>-th ray is 
<C>(imrays[i]:imobs[1]</C><M>\to</M><C>imobs[i])</C>. 
</Item>
</List> 
This data is stored in the attribute <C>MappingToSinglePieceData</C>. 
<P/> 
So an alternative way to construct a homomorphism of groupoids is to 
make a call of the form  
<C>GroupoidHomomorphism(src,rng,rhom,imobs,imrays)</C>. 
<P/> 
In the following example the same homomorphism is constructed 
using both methods.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> gen1 := GeneratorsOfGroupoid( Gq8 ); 
[ [x : -28 -> -28], [y : -28 -> -28], [y2 : -28 -> -28], 
  [<identity> of ... : -28 -> -27] ]
gap> gen2 := GeneratorsOfGroupoid( Hd8b ); 
[ [(1,2,3,4) : -14 -> -14], [(1,3) : -14 -> -14], [(1,2,3) : -14 -> -13], 
  [(1,2,4) : -14 -> -12] ]
gap> images := [ gen2[1]^2, gen2[1]*gen2[2], IdentityArrow(Hd8b,-14), gen2[4] ];
[ [(1,3)(2,4) : -14 -> -14], [(1,2)(3,4) : -14 -> -14], [() : -14 -> -14], 
  [(1,2,4) : -14 -> -12] ]
gap> mor1 := GroupoidHomomorphism( Gq8, Hd8b, gen1, images );
groupoid homomorphism : Gq8 -> Hd8b
[ [ [x : -28 -> -28], [y : -28 -> -28], [y2 : -28 -> -28], 
      [<identity> of ... : -28 -> -27] ], 
  [ [(1,3)(2,4) : -14 -> -14], [(1,2)(3,4) : -14 -> -14], [() : -14 -> -14], 
      [(1,2,4) : -14 -> -12] ] ]
gap> genq8 := GeneratorsOfGroup( q8 );;
gap> imh := [ (1,3)(2,4), (1,2)(3,4), () ];;
gap> h := GroupHomomorphismByImages( q8, d8, genq8, imh );                     
[ x, y, y2 ] -> [ (1,3)(2,4), (1,2)(3,4), () ]
gap> mor2 := GroupoidHomomorphism( Gq8, Hd8b, h, [-14,-12], [(),(1,2,4)] );;
gap> mor1=mor2;
true
gap> e := Arrow( Gq8, Product(genq8), -27, -28 );
[x*y*y2 : -27 -> -28]
gap> ImageElm( mor2, e );
[(2,4,3) : -12 -> -14]
]]>
</Example>

</Section> 

<Section Label="sec-hom-attr-prop">
<Heading>Properties and attributes of groupoid homomorphisms</Heading>

<Subsection Label="subsec-prop-homs">
<Heading>Properties of a groupoid homomorphism</Heading>
The properties listed in subsection <Ref Sect="sec-hompieces"/> 
for homomorphisms of magmas with objects also apply to groupoid homomorphisms.
<Index Key="IsInjectiveOnObjects" Subkey="for groupoid homomorphisms"></Index> 
<Index Key="IsSurjectiveOnObjects" Subkey="for groupoid homomorphisms"></Index> 
<Index Key="IsBijectiveOnObjects" Subkey="for groupoid homomorphisms"></Index> 
<Index Key="IsAutomorphismWithObjects" Subkey="for groupoid homomorphisms">
</Index> 
<Index Key="IsEndomorphismWithObjects" Subkey="for groupoid homomorphisms">
</Index> 
<Index Key="IsInjective" Subkey="for groupoid homomorphisms"></Index> 
<Index Key="IsSurjective" Subkey="for groupoid homomorphisms"></Index> 
<P/>
<Example>
<![CDATA[
gap> [ IsInjectiveOnObjects( mor2 ), IsSurjectiveOnObjects( mor2 ) ]; 
[ true, false ]
gap> [ IsInjective( mor2 ), IsSurjective( mor2 ) ];
[ false, false ]
gap> ad8 := GroupHomomorphismByImages( d8, d8, 
>               [ (1,2,3,4), (1,3) ], [ (1,4,3,2), (2,4) ] );; 
gap> md8 := GroupoidHomomorphism( Gd8, Gd8, ad8, [-7,-9,-8], [(),(1,3),(2,4)] );
groupoid homomorphism : Gd8 -> Gd8
[ [ [(1,2,3,4) : -9 -> -9], [(1,3) : -9 -> -9], [() : -9 -> -8], 
      [() : -9 -> -7] ], 
  [ [(1,4,3,2) : -7 -> -7], [(2,4) : -7 -> -7], [(1,3) : -7 -> -9], 
      [(2,4) : -7 -> -8] ] ]
gap> IsBijectiveOnObjects( md8 );
true
gap> [ IsInjective( md8 ), IsSurjective( md8 ) ];  
[ true, true ]
gap> [ IsEndomorphismWithObjects( md8 ), IsAutomorphismWithObjects( md8 ) ];
[]]>
</Example>

</Subsection>

<Subsection Label="subsec-attr-homs">
<Heading>Attributes of a groupoid homomorphism</Heading>
The attributes of a groupoid homomorphism <C>mor</C> from a single piece 
groupoid cover both forms of construction defined above. 
<List>
<Item>
<C>S = Source(mor)</C> is the source groupoid of the homomorphism; 
</Item>
<Item>
<C>R = Range(mor)</C> is the range groupoid of the homomorphism; 
</Item>
<Item>
<C>RootGroupHomomorphism(mor)</C> is the group homomorphism from the root group 
of <C>S</C> to the group at the image object in <C>R</C> 
of the root object in <C>S</C>; 
</Item>
<Item>
<C>ImagesOfObjects(mor)</C> is the list of objects in <C>R</C>
which are the images of the objects in <C>S</C>; 
</Item>
<Item>
<C>ImageElementsOfRays(mor)</C> is the list of group elements in those arrows 
in <C>R</C> which are the images of the rays in <C>S</C>; 
</Item>
<Item>
<C>MappingGeneratorsImages(mor)</C> is the two element list containing 
the list of generators in <C>S</C> and the list of their images in <C>R</C>; 
</Item>
<Item>
<C>MappingToSinglePieceData(mor)</C> is a list with three elements: 
the root group homomorphism; the images of the objects; 
and the images of the rays. 
</Item>
</List>
For other types of homomorphism the attributes are very similar. 
<P/> 
The operation <C>ObjectGroupHomomorphism</C>, though an operation, 
is included in this section for convenience. 
</Subsection>


<ManSection>
   <Attr Name="RootGroupHomomorphism"
         Arg="hom" />
<Description>
This is the group homomorphism from the root group of the source groupoid 
to the group at the image object in the range groupoid 
of the root object in the source.  
</Description> 
</ManSection> 

<ManSection>
   <Attr Name="ImagesOfObjects"
         Arg="hom" />
<Description>
This is the list of objects in the range groupoid 
which are the images of the objects in the source. 
</Description> 
</ManSection> 

<ManSection>
   <Attr Name="ImageElementsOfRays"
         Arg="hom" />
<Description>
This is the list of group elements in those arrows 
in the range groupoid which are the images of the rays in the source. 
</Description> 
</ManSection>
<Example>
<![CDATA[
gap> RootGroupHomomorphism( mor2 );
[ x, y, y2 ] -> [ (1,3)(2,4), (1,2)(3,4), () ]
gap> ImagesOfObjects( mor2 );      
[ -14, -12 ]
gap> ImageElementsOfRays( mor2 );
[ (), (1,2,4) ]
]]>
</Example>

<ManSection>
   <Oper Name="ObjectGroupHomomorphism"
         Arg="gpdhom, obj" />
<Description>
This operations gives the group homomorphism from an object group of 
the source to the object group at the image object in the range.  
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> ObjectGroupHomomorphism( mor1, -27 );
[ x, y, y2 ] -> [ (1,4)(2,3), (1,3)(2,4), () ]
]]>
</Example>

</Section> 

<Section Label="sec-spec-homs">
<Heading>Special types of groupoid homomorphism</Heading>

In this section we mention inclusion mappings of subgroupoids; 
and mappings restricted to a source subgroupoid.  
We also discuss various types of isomorphism: to a different set of objects; 
to a permutation groupoid; to a pc-groupoid. 

<ManSection>
   <Oper Name="InclusionMappingGroupoids"
         Arg="gpd, sgpd" />
<Description>
The operation <C>InclusionMappingGroupoids(gpd,sgpd)</C> 
returns the inclusion homomorphism from the subgroupoid <C>sgpd</C> 
to <C>gpd</C>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> inc := InclusionMappingGroupoids( Hs4, Hd8b );
groupoid homomorphism : Hd8b -> Hs4
[ [ [(1,2,3,4) : -14 -> -14], [(1,3) : -14 -> -14], [(1,2,3) : -14 -> -13], 
      [(1,2,4) : -14 -> -12] ], 
  [ [(1,2,3,4) : -14 -> -14], [(1,3) : -14 -> -14], [(1,2,3) : -14 -> -13], 
      [(1,2,4) : -14 -> -12] ] ]
]]>
</Example>

<ManSection>
   <Oper Name="RestrictedMappingGroupoids"
         Arg="mor, sgpd" />
   <Attr Name="ParentMappingGroupoids"
         Arg="mor" />
<Description>
The operation <C>RestrictedMappingGroupoids(mor,sgpd)</C> 
returns the restriction of the homomorphism <C>mor</C> 
to the subgroupoid <C>sgpd</C> of its source. 
The range is usually set to the <C>ImagesSource</C> of the restriction. 
The restriction is assigned the attribute <C>ParentMappingGroupoids</C> 
with value <C>mor</C> (or that of <C>mor</C> is one exists). 
For another example see section <Ref Sect="sec-mxreps"/>.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> max := MaximalDiscreteSubgroupoid( Hd8b );;
gap> res := RestrictedMappingGroupoids( inc, max );
groupoid homomorphism from several pieces : 
groupoid homomorphism : 
[ [ [(1,2,3,4) : -14 -> -14], [(1,3) : -14 -> -14] ], 
  [ [(1,2,3,4) : -14 -> -14], [(1,3) : -14 -> -14] ] ]
groupoid homomorphism : 
[ [ [(1,4,2,3) : -13 -> -13], [(1,2) : -13 -> -13] ], 
  [ [(1,4,2,3) : -13 -> -13], [(1,2) : -13 -> -13] ] ]
groupoid homomorphism : 
[ [ [(1,2,4,3) : -12 -> -12], [(2,3) : -12 -> -12] ], 
  [ [(1,2,4,3) : -12 -> -12], [(2,3) : -12 -> -12] ] ]
]]>
</Example>

<ManSection>
   <Oper Name="IsomorphismNewObjects"
         Arg="src,objlist" Label="for groupoids" />
<Description>
The operation <C>IsomorphismNewObjects(gpd,obs)</C> returns the isomorphism 
from a groupoid <C>gpd</C> to a groupoid with the same object group and ray 
elements but with a different set <C>obs</C> of objects. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> iso1 := IsomorphismNewObjects( Hs4, [-30,-20,-10] ); 
groupoid homomorphism : 
[ [ [(1,2,3,4) : -14 -> -14], [(3,4) : -14 -> -14], [() : -14 -> -13], 
      [() : -14 -> -12] ], 
  [ [(1,2,3,4) : -30 -> -30], [(3,4) : -30 -> -30], [() : -30 -> -20], 
      [() : -30 -> -10] ] ]
gap> inc2 := mor2*inc*iso1;
groupoid homomorphism : 
[ [ [x : -28 -> -28], [y : -28 -> -28], [y2 : -28 -> -28], 
      [<identity> of ... : -28 -> -27] ], 
  [ [(1,3)(2,4) : -30 -> -30], [(1,2)(3,4) : -30 -> -30], [() : -30 -> -30], 
      [(1,2,4) : -30 -> -10] ] ]
]]>
</Example>

<ManSection>
   <Oper Name="IsomorphismStandardGroupoid"
         Arg="gpd,obs" />
<Description>
The operation <C>IsomorphismStandardGroupoid(gpd,obs)</C> 
returns the isomorphism from a groupoid with rays to the groupoid of type 
<C>IsDirectProductWithCompleteDigraphDomain</C> 
on the given set <C>obs</C> of objects.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> iso2 := IsomorphismStandardGroupoid( Hd8b, [-23,-22,-21] );
groupoid homomorphism : 
[ [ [(1,2,3,4) : -14 -> -14], [(1,3) : -14 -> -14], [(1,2,3) : -14 -> -13], 
      [(1,2,4) : -14 -> -12] ], 
  [ [(1,2,3,4) : -23 -> -23], [(1,3) : -23 -> -23], [() : -23 -> -22], 
      [() : -23 -> -21] ] ]
gap> inv2 := InverseGeneralMapping( iso2 );
groupoid homomorphism : 
[ [ [(1,2,3,4) : -23 -> -23], [(1,3) : -23 -> -23], [() : -23 -> -22], 
      [() : -23 -> -21] ], 
  [ [(1,2,3,4) : -14 -> -14], [(1,3) : -14 -> -14], [(1,2,3) : -14 -> -13], 
      [(1,2,4) : -14 -> -12] ] ]
]]>
</Example>

This operation may also be used to provide a standard form for groupoids 
of type <C>IsGroupoidByIsomorphisms</C> as described in subsection 
<Ref Oper="GroupoidByIsomorphisms"/>. 
<P/> 
<Example>
<![CDATA[
gap> G2;
single piece groupoid with rays: < s3a, [ -7, -6, -5 ], 
[ [ (), () ], [ (), <identity> of ... ], [ (), <identity ...> ] ] >
gap> isoG2 := IsomorphismStandardGroupoid( G2, [-17,-16,-15] ); 
groupoid homomorphism : 
[ [ [[ (1,2), (1,2) ] : -7 -> -7], [[ (2,3), (2,3) ] : -7 -> -7], 
      [[ (), <identity> of ... ] : -7 -> -6], [[ (), <identity ...> ] : -7 -> 
        -5] ], 
  [ [(1,2) : -17 -> -17], [(2,3) : -17 -> -17], [() : -17 -> -16], 
      [() : -17 -> -15] ] ]
]]>
</Example>

<ManSection>
   <Attr Name="IsomorphismPermGroupoid"
         Arg="gpd" />
   <Oper Name="IsomorphismPcGroupoid"
         Arg="gpd" />
<Description>
The operation <C>IsomorphismPermGroupoid(gpd)</C> returns an isomorphism 
from a groupoid <C>gpd</C> to a groupoid with the same objects but with an 
isomorphic permutation group. 
Similarly, <C>IsomorphismPcGroupoid(gpd)</C> changes the group into a pc-group 
(if appropriate). 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> N2 := NormalSubgroups( q8 )[2];; 
gap> Hq8 := SubgroupoidWithRays( Gq8, N2, [ One(q8), q8.1 ] ); 
single piece groupoid with rays: < N2, [ -28, -27 ], [ <identity> of ..., x 
 ] >
gap> isoHq8 := IsomorphismPermGroupoid( Hq8 );
groupoid homomorphism : 
[ [ y : -28 -> -28], [y2 : -28 -> -28], [x : -28 -> -27] ], 
  [ [(1,3,4,7)(2,5,6,8) : -28 -> -28], [(1,4)(2,6)(3,7)(5,8) : -28 -> -28], 
      [(1,2,4,6)(3,8,7,5) : -28 -> -27] ] ]
]]>
</Example>

</Section>


<Section Label="sec-homsto">
<Heading>Homomorphisms to a connected groupoid</Heading>

<ManSection>
   <Oper Name="HomomorphismToSinglePiece"
         Arg="src, rng, piecehoms" Label="for groupoids" />
<Description>
When <M>G</M> is made up of two or more pieces, all of which get mapped 
to a connected groupoid, we have a <E>homomorphism to a single piece</E>. 
The third input parameter in this case is a list of the individual 
homomorphisms <E>from</E> the single pieces (in the correct order!). 
See section <Ref Sect="sec-mwohom"/> for the corresponding operation 
on homomorphisms of magmas with objects. 
<P/>
In the following example the source <C>V3</C> of <C>homV3</C> has three pieces, 
and one of the component homomorphisms is an <C>IdentityMapping</C> 
<Index Key="IdentityMapping"> <C>IdentityMapping</C> </Index>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> gend12 := [ (15,16,17,18,19,20), (15,20)(16,19)(17,18) ];; 
gap> d12 := Group( gend12 );; 
gap> Gd12 := Groupoid( d12, [-37,-36,-35,-34] );;
gap> SetName( d12, "d12" );  
gap> SetName( Gd12, "Gd12" );
gap> s3 := Subgroup( d12, [ (15,17,19)(16,18,20), (15,20)(16,19)(17,18) ] );;
gap> Gs3 := SubgroupoidByPieces( Gd12, [ [ s3, [-36,-35,-34] ] ] );;
gap> SetName( s3, "s3" );  
gap> SetName( Gs3, "Gs3" );
gap> gend8 := GeneratorsOfGroup( d8 );;
gap> imhd8 := [ ( ), (15,20)(16,19)(17,18) ];;
gap> hd8 := GroupHomomorphismByImages( d8, s3, gend8, imhd8 );;
gap> homd8 := GroupoidHomomorphism( Gd8, Gs3, hd8 ); 
groupoid homomorphism : Gd8 -> Gs3
[ [ [(1,2,3,4) : -9 -> -9], [(1,3) : -9 -> -9], [() : -9 -> -8], 
      [() : -9 -> -7] ], 
  [ [() : -36 -> -36], [(15,20)(16,19)(17,18) : -36 -> -36], 
      [() : -36 -> -35], [() : -36 -> -34] ] ]
gap> hc6 := GroupHomomorphismByImages( c6, s3, 
>            [(5,6,7)(8,9)], [(15,16)(17,20)(18,19)] );;
gap> Fs3 := SubgroupoidByObjects( Gs3, [ -35 ] );; 
gap> SetName( Fs3, "Fs3" ); 
gap> homc6 := GroupoidHomomorphism( Gc6, Fs3, hc6 );;
gap> incFs3 := InclusionMappingGroupoids( Gs3, Fs3 );; 
gap> ihomc6 := homc6 * incFs3; 
groupoid homomorphism : Gc6 -> Gs3
[ [ [(5,6,7)(8,9) : -6 -> -6] ], [ [(15,16)(17,20)(18,19) : -35 -> -35] ] ]
gap> idGs3 := IdentityMapping( Gs3 );;
gap> V3 := ReplaceOnePieceInUnion( U3, 1, Gs3 ); 
groupoid with 3 pieces:
[ Gs3, Gd8, Gc6 ]
gap> homs3 := [ idGs3, homd8, ihomc6 ];; 
gap> homV3 := HomomorphismToSinglePiece( V3, Gs3, homs3 );; 
gap> Display( homV3 );         
homomorphism to single piece groupoid with pieces:
(1) :  groupoid mapping: [ Gs3 ] -> [ Gs3 ]
root homomorphism: [ [ (15,17,19)(16,18,20), (15,20)(16,19)(17,18) ], 
  [ (15,17,19)(16,18,20), (15,20)(16,19)(17,18) ] ]
images of objects: [ -36, -35, -34 ]
   images of rays: [ [() : -36 -> -36], [() : -36 -> -35], [() : -36 -> -34] ]
(2) :  groupoid mapping: [ Gd8 ] -> [ Gs3 ]
root homomorphism: [ [ (1,2,3,4), (1,3) ], [ (), (15,20)(16,19)(17,18) ] ]
images of objects: [ -36, -35, -34 ]
   images of rays: [ [() : -36 -> -36], [() : -36 -> -35], [() : -36 -> -34] ]
(3) :  groupoid mapping: [ Gc6 ] -> [ Gs3 ]
root homomorphism: [ [ (5,6,7)(8,9) ], [ (15,16)(17,20)(18,19) ] ]
images of objects: [ -35 ]
   images of rays: [ [() : -35 -> -35] ]
]]>
</Example>

<ManSection Label="subsec-hom-from-disc">
   <Oper Name="GroupoidHomomorphismFromHomogeneousDiscrete"
         Arg="src, rng, homs, oims" />
<Description>
This operation requires the source and range; 
a list of homomorphisms from object group to object group; 
and a list of the image objects. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Dd8 := MaximalDiscreteSubgroupoid( Gd8 );
homogeneous, discrete groupoid: < d8, [ -9, -8, -7 ] >
gap> id8 := IdentityMapping( d8 );; 
gap> GroupoidHomomorphismFromHomogeneousDiscrete( Dd8, Gd8, [id8,id8,id8], 
>    [-8,-7,-9] );                                                        
groupoid homomorphism : morphism from a homogeneous discrete groupoid:
[ -9, -8, -7 ] -> [ -8, -7, -9 ]
object homomorphisms:
IdentityMapping( d8 )
IdentityMapping( d8 )
IdentityMapping( d8 )
]]>
</Example>

</Section>


<Section Label="sec-genhoms">
<Heading>Homomorphisms to more than one piece</Heading>

<ManSection>
   <Oper Name="HomomorphismByUnion"
         Arg="src, rng, homs" Label="for groupoids" />
<Description>
As in section <Ref Sect="sec-hompieces"/>,  
when the range <M>H</M> has more than one connected component, 
a homomorphism is a union of homomorphisms, one for each piece in the range. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> isoq8 := IsomorphismNewObjects( Gq8, [-38,-37] ); 
groupoid homomorphism : 
[ [ [x : -28 -> -28], [y : -28 -> -28], [y2 : -28 -> -28], 
      [<identity> of ... : -28 -> -27] ], 
  [ [x : -38 -> -38], [y : -38 -> -38], [y2 : -38 -> -38], 
      [<identity> of ... : -38 -> -37] ] ]
gap> Gq8b := Range( isoq8 );; 
gap> SetName( Gq8b, "Gq8b" ); 
gap> V4 := UnionOfPieces( [ V3, Gq8 ] ); 
groupoid with 4 pieces:
[ Gs3, Gq8, Gd8, Gc6 ]
gap> SetName( V4, "V4" ); 
gap> Vs3q8b := UnionOfPieces( [ Gs3, Gq8b ] );; 
gap> SetName( Vs3q8b, "Vs3q8b" ); 
gap> hom4 := HomomorphismByUnion( V4, Vs3q8b, [ homV3, isoq8 ] );; 
gap> Display( hom4 );
magma homomorphism: V4 -> Vs3q8b with pieces :
[ Pcgs([ x, y, y2 ]) -> [ x, y, y2 ], [ -38, -37 ], 
  [ <identity> of ..., <identity> of ... ] ]
(1) :  groupoid mapping: [ Gs3 ] -> [ Gs3 ]
root homomorphism: [ [ (15,17,19)(16,18,20), (15,20)(16,19)(17,18) ], 
  [ (15,17,19)(16,18,20), (15,20)(16,19)(17,18) ] ]
images of objects: [ -36, -35, -34 ]
   images of rays: [ [() : -36 -> -36], [() : -36 -> -35], [() : -36 -> -34] ]
(2) :  groupoid mapping: [ Gd8 ] -> [ Gs3 ]
root homomorphism: [ [ (1,2,3,4), (1,3) ], [ (), (15,20)(16,19)(17,18) ] ]
images of objects: [ -36, -35, -34 ]
   images of rays: [ [() : -36 -> -36], [() : -36 -> -35], [() : -36 -> -34] ]
(3) :  groupoid mapping: [ Gc6 ] -> [ Gs3 ]
root homomorphism: [ [ (5,6,7)(8,9) ], [ (15,16)(17,20)(18,19) ] ]
images of objects: [ -35 ]
   images of rays: [ [() : -35 -> -35] ]
]]>
</Example>

<ManSection>
   <Oper Name="IsomorphismGroupoids"
         Arg="A,B" />
<Description>
When <M>A,B</M> are two single piece groupoids, they are isomorphic provided 
they have the same number of objects and the root groups are isomorphic. 
<P/> 
When <M>A=[A_1,\ldots,A_n],~ B=[B_1,\ldots,B_n]</M> 
are both unions of connected groupoids, they are isomorphic if 
there is a permutation <M>\pi</M> of <M>[1,\ldots,n]</M> 
such that <M>A_i</M> is isomorphic to <M>B_{\pi(i)}</M> for all <M>i</M>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> s3a := Group( (1,2,3), (2,3) );; 
gap> s3b := Group( (4,6,8)(5,7,9), (4,9)(5,8)(6,7) );;
gap> s3c := Group( (4,6,8)(5,7,9), (5,9)(6,8) );;
gap> Ga := SinglePieceGroupoid( s3a, [-23,-22,-21] );; 
gap> SetName( Ga, "Ga" ); 
gap> Gb := SinglePieceGroupoid( s3b, [-6,-5,-4] );; 
gap> SetName( Gb, "Gb" ); 
gap> Gc := SinglePieceGroupoid( s3c, [-9,-8,-7] );; 
gap> SetName( Gc, "Gc" ); 
gap> c6a := Group( (1,2,3,4,5,6) );; 
gap> c6b := Group( (7,8)(9,10,11) );;
gap> c6c := Group( (12,13)(14,15)(16,17,18)(19,20,21)(22,23,24,25,26,27) );; 
gap> Ha := SinglePieceGroupoid( c6a, [-3,-2,-1] );; 
gap> SetName( Ha, "Ha" ); 
gap> Hb := SinglePieceGroupoid( c6b, [-16,-15,-14] );; 
gap> SetName( Hb, "Hb" ); 
gap> Hc := SinglePieceGroupoid( c6c, [-19,-18,-17] );; 
gap> SetName( Hc, "Hc" ); 
gap> IsomorphismGroupoids( Ga, Gb ); 
groupoid homomorphism : Ga -> Gb
[ [ [(1,2,3) : -23 -> -23], [(2,3) : -23 -> -23], [() : -23 -> -22], 
      [() : -23 -> -21] ], 
  [ [(4,6,8)(5,7,9) : -6 -> -6], [(4,9)(5,8)(6,7) : -6 -> -6], 
      [() : -6 -> -5], [() : -6 -> -4] ] ]
gap> IsomorphismGroupoids( Ga, Ha );
fail
gap> A := UnionOfPieces( [ Ha, Gb, Gc, Hb ] ); 
groupoid with 4 pieces:
[ Hb, Gc, Gb, Ha ]
gap> B := UnionOfPieces( [ Gc, Hb, Hc, Ga ] ); 
groupoid with 4 pieces:
[ Ga, Hc, Hb, Gc ]
gap> iso := IsomorphismGroupoids( A, B );; 
gap> Print( List( PiecesOfMapping(iso), p -> [Source(p),Range(p)] ) );
[ [ Gc, Ga ], [ Hb, Hc ], [ Ha, Hb ], [ Gb, Gc ] ]
]]>
</Example>

</Section>


<Section Label="sec-autos">
<Heading>Automorphisms of groupoids</Heading>

In this sections we consider automorphisms of single piece groupoids, 
then homogeneous discrete groupoids, and then homogeneous groupoids. 

<ManSection>
   <Oper Name="GroupoidAutomorphismByObjectPerm"
         Arg="gpd, imobs" />
   <Oper Name="GroupoidAutomorphismByGroupAuto"
         Arg="gpd, gpiso" />
   <Oper Name="GroupoidAutomorphismByRayShifts"
         Arg="gpd, imrays" />
   <Oper Name="GroupoidInnerAutomorphism" 
         Arg="gpd, arrow" />
<Description>
We first describe automorphisms of a groupoid <M>G</M> where 
<M>G</M> is the direct product of a group <M>g</M> and a complete digraph. 
The automorphism group is generated by three types of automorphism: 
<List>
<Item>
given a permutation <M>\pi</M> of the <M>n</M> objects, we define 
<M>\pi : G \to G,~ (o_i,g,o_j) \mapsto (o_{\pi i},g,o_{\pi j})</M>; 
</Item>
<Item>
given an automorphism <M>\alpha</M> of the root group <M>g</M>, we define 
<M>\alpha : G \to G,~ (o_i,g,o_j) \mapsto (o_i,\alpha g,o_j)</M>;  
</Item>
<Item>
given <M>L = [1,g_2,g_3,\ldots,g_n] \in g^n</M> we define 
<M>\theta_L : G \to G,~ (o_i,g,o_j) \mapsto (o_i,g_i^{-1}gg_j,o_j)</M> 
so that, in particular, for all <M>j</M> the rays <M>(r_j : o_1 \to o_j)</M> 
are shifted by <M>g_j\;</M>: they map to <M>(r_jg_j : o_1 \to o_j)</M>; 
</Item>
<Item>
<Index>inner automorphism</Index> 
given <M>g \in G</M>, the <E>inner automorphism</E> of <M>G</M> by <M>g</M> is 
the mapping <M>h \mapsto h^g</M> wehere conjugation of arrows 
is defined in section <Ref Sect="sec-conj"/>.
</Item>
</List> 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> a4 := Subgroup( s4, [(1,2,3),(2,3,4)] );; 
gap> SetName( a4, "a4" ); 
gap> gensa4 := GeneratorsOfGroup( a4 );; 
gap> Ga4 := SubgroupoidByPieces( Gs4, [ [a4, [-15,-13,-11]] ] ); 
single piece groupoid: < a4, [ -15, -13, -11 ] >
gap> SetName( Ga4, "Ga4" ); 
gap> d := Arrow( Ga4, (1,3,4), -11, -13 ); 
[(1,3,4) : -11 -> -13]
gap> aut1 := GroupoidAutomorphismByObjectPerm( Ga4, [-13,-11,-15] );; 
gap> Display( aut1 ); 
 groupoid mapping: [ Ga4 ] -> [ Ga4 ]
root homomorphism: [ [ (1,2,3), (2,3,4) ], [ (1,2,3), (2,3,4) ] ]
images of objects: [ -13, -11, -15 ]
   images of rays: [ [() : -13 -> -13], [() : -13 -> -11], [() : -13 -> -15] ]
gap> d1 := ImageElm( aut1, d ); 
[(1,3,4) : -15 -> -11]
gap> h2 := GroupHomomorphismByImages( a4, a4, gensa4, [(2,3,4), (1,3,4)] );; 
gap> aut2 := GroupoidAutomorphismByGroupAuto( Ga4, h2 );; 
gap> Display( aut2 ); 
 groupoid mapping: [ Ga4 ] -> [ Ga4 ]
root homomorphism: [ [ (1,2,3), (2,3,4) ], [ (2,3,4), (1,3,4) ] ]
images of objects: [ -15, -13, -11 ]
   images of rays: [ [() : -15 -> -15], [() : -15 -> -13], [() : -15 -> -11] ]
gap> d2 := ImageElm( aut2, d1 );
[(1,2,4) : -15 -> -11]
gap> im3 := [(), (1,3,2), (2,4,3)];; 
gap> aut3 := GroupoidAutomorphismByRayShifts( Ga4, im3 );; 
gap> Display( aut3 ); 
 groupoid mapping: [ Ga4 ] -> [ Ga4 ]
root homomorphism: [ [ (1,2,3), (2,3,4) ], [ (1,2,3), (2,3,4) ] ]
images of objects: [ -15, -13, -11 ]
   images of rays: [ [() : -15 -> -15], [(1,3,2) : -15 -> -13], 
  [(2,4,3) : -15 -> -11] ]
gap> d3 := ImageElm( aut3, d2 );
[(1,4)(2,3) : -15 -> -11]
gap> d0 := Arrow( Ga4, (2,3,4), -11, -13 );; 
gap> aut4 := GroupoidInnerAutomorphism( Ga4, d0 );;
gap> Display( aut4 );
 groupoid mapping: [ Ga4 ] -> [ Ga4 ]
root homomorphism: [ [ (1,2,3), (2,3,4) ], [ (1,2,3), (2,3,4) ] ]
images of objects: [ -15, -11, -13 ]
   images of rays: [ [() : -15 -> -15], [(2,4,3) : -15 -> -11], 
  [(2,3,4) : -15 -> -13] ]
gap> d4 := ImageElm( aut4, d3 );
[(1,2,4) : -15 -> -13]
]]>
</Example>


<Subsection Label="subsec-autos-with-rays">
<Heading>Automorphisms of a groupoid with rays</Heading>

Let <M>S</M> be a wide subgroupoid with rays of a standard groupoid <M>G</M>. 
<P/> 
An automorphism of the root group extends to the whole of <M>S</M> 
with the rays fixed by the automorphism.
<P/> 
An automorphism of <M>G</M> by permuting the objects 
may map <M>S</M> to a different subgroupoid.  
So we construct an isomorphism <M>\iota</M> from <M>S</M> 
to a standard groupoid <M>T</M>, constgruct <M>\alpha</M> 
permuting the objects of <M>T</M>, and return <M>\iota*\alpha*\iota^{-1}</M>.  
<P/>
For an automorphism by ray shifts we require that the shifts are 
elements of the root group of <M>S</M>. 
<P/>
<Example>
<![CDATA[
gap> s4c := Group( (1,2,3,4), (3,4) );; 
gap> SetName( s4c, "s4c" );
gap> s3c := Subgroup( s4c, [ (1,2), (2,3) ] );; 
gap> SetName( s3c, "s3c" ); 
gap> Gs4c := SinglePieceGroupoid( s4c, [-9,-8,-7,-6] );; 
gap> SetName( Gs4c, "Gs4c" ); 
gap> Hs3c := SubgroupoidWithRays( Gs4c, s3c, [ (), (1,4), (2,4), (3,4) ] );; 
gap> SetName( Hs3c, "Hs3c" ); 
gap> ## (1) automorphism by group auto 
gap> a1 := GroupHomomorphismByImages( s3c, s3c, [(1,2),(2,3)], [(1,3),(2,3)] );;
gap> aut1 := GroupoidAutomorphismByGroupAuto( Hs3c, a1 );
groupoid homomorphism : Hs3c -> Hs3c
[ [ [(1,2) : -9 -> -9], [(2,3) : -9 -> -9], [(1,4) : -9 -> -8], 
      [(2,4) : -9 -> -7], [(3,4) : -9 -> -6] ], 
  [ [(1,3) : -9 -> -9], [(2,3) : -9 -> -9], [(1,4) : -9 -> -8], 
      [(2,4) : -9 -> -7], [(3,4) : -9 -> -6] ] ]
gap> a := Arrow( Hs3c, (2,3,4), -8, -8 );
[(2,3,4) : -8 -> -8]
gap> ImageElm( aut1, a );
[(2,4,3) : -8 -> -8]
gap> b := Arrow( Hs3c, (1,2,3,4), -7, -6 );
[(1,2,3,4) : -7 -> -6]
gap> ##  b = (2,4)(1,2)(3,4) -> (2,4)(1,3)(3,4)
gap> ImageElm( aut1, b );
[(1,4,2,3) : -7 -> -6]
gap> ## (2) automorphism by object perm 
gap> aut2 := GroupoidAutomorphismByObjectPerm( Hs3c, [-8,-7,-6,-9] );
groupoid homomorphism : Hs3c -> Hs3c
[ [ [(1,2) : -9 -> -9], [(2,3) : -9 -> -9], [(1,4) : -9 -> -8], 
      [(2,4) : -9 -> -7], [(3,4) : -9 -> -6] ], 
  [ [(2,4) : -8 -> -8], [(2,3) : -8 -> -8], [(1,2,4) : -8 -> -7], 
      [(1,3,4) : -8 -> -6], [(1,4) : -8 -> -9] ] ] 
gap> ImageElm( aut2, a );                                           
[(1,4,3) : -7 -> -7]
gap> ImageElm( aut2, b );                                           
[(1,2)(3,4) : -6 -> -9]
gap> ## (3) automorphism by ray shifts 
gap> aut3 := GroupoidAutomorphismByRayShifts( Hs3c, [(),(2,3),(1,3),(1,2)] );   
groupoid homomorphism : Hs3c -> Hs3c
[ [ [(1,2) : -9 -> -9], [(2,3) : -9 -> -9], [(1,4) : -9 -> -8], 
      [(2,4) : -9 -> -7], [(3,4) : -9 -> -6] ], 
  [ [(1,2) : -9 -> -9], [(2,3) : -9 -> -9], [(1,4)(2,3) : -9 -> -8], 
      [(1,3)(2,4) : -9 -> -7], [(1,2)(3,4) : -9 -> -6] ] ]
gap> ImageElm( aut3, a );
[(2,4,3) : -8 -> -8]
gap> ImageElm( aut3, b );
[(1,4,2,3) : -7 -> -6]
gap> e86 := Arrow( Hs3c, (1,3,2,4), -8, -6 );;
gap> aut86 := GroupoidInnerAutomorphism( Hs3c, e86 );
groupoid homomorphism : Hs3c -> Hs3c
[ [ [(1,2) : -9 -> -9], [(2,3) : -9 -> -9], [(1,4) : -9 -> -8], 
      [(2,4) : -9 -> -7], [(3,4) : -9 -> -6] ], 
  [ [(1,2) : -9 -> -9], [(2,3) : -9 -> -9], [(2,4,3) : -9 -> -6], 
      [(2,4) : -9 -> -7], [(1,4)(2,3) : -9 -> -8] ] ]
]]>
</Example>
</Subsection>


<ManSection>
   <Oper Name="AutomorphismGroupOfGroupoid"
         Arg="gpd" />
   <Oper Name="NiceObjectAutoGroupGroupoid"
         Arg="gpd, aut" />
<Description>
As above, let <M>G</M> be the direct product of a group <M>g</M> 
and a complete digraph with <M>n</M> objects. 
The <Index Key="AutomorphismGroup"> <C>AutomorphismGroup</C> </Index> 
<C>AutomorphismGroup</C> <M>\Aut(G)</M> of <M>G</M> is isomorphic to 
the quotient of <M>S_n \times A \times g^n</M> 
by a subgroup isomorphic to <M>g</M>, 
where <M>A</M> is the automorphism group of <M>g</M> 
and <M>S_n</M> is the symmetric group on the <M>n</M> objects. 
This is one of the main topics in <Cite Key="AlWe" />. 
<P/> 
If <M>H</M> is the union of <M>k</M> groupoids, all isomorphic to <M>G</M>, 
then <M>\Aut(H)</M> is isomorphic to <M>S_k \ltimes \Aut(G)</M>. 
<P/>
The function <C>NiceObjectAutoGroupGroupoid</C> takes a groupoid 
and a subgroup of its automorphism group and retuns a 
<E>nice monomorphism</E> from this automorphism group to a pc-group, 
if one is available.  
The current implementation is experimental. 
Note that <C>ImageElm</C> at present only works on generating elements.  
<P/> 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> AGa4 := AutomorphismGroupOfGroupoid( Ga4 ); 
Aut(Ga4)
gap> Length( GeneratorsOfGroup( AGa4 ) );
8
gap> AGgens := GeneratorsOfGroup( AGa4);; 
gap> NGa4 := NiceObject( AGa4 );; 
gap> MGa4 := NiceMonomorphism( AGa4 );; 
gap> Size( AGa4 ); 
20736
gap> SetName( AGa4, "AGa4" ); 
gap> SetName( NGa4, "NGa4" ); 
gap> ##  cannot test images of AGgens because of random variations 
gap> ##  Now do some tests!
gap> mgi := MappingGeneratorsImages( MGa4 );; 
gap> autgen := mgi[1];; 
gap> pcgen := mgi[2];;
gap> ngen := Length( autgen );; 
gap> ForAll( [1..ngen], i -> Order(autgen[i]) = Order(pcgen[i]) ); 
true
]]>
</Example>


<Subsection Label="subsec-inner-autos">
<Heading>Inner automorphisms</Heading>

The inner automorphism subgroup <M>\mathrm{Inn}(G)</M> 
<Index Key="inner automorphism group"> inner automorphism group </Index> 
of the automorphism group of <M>G</M> is the group of inner automorphisms 
<M>\wedge a : b \mapsto b^a</M> for <M>a \in G</M>. 
It is <E>not</E> the case that the map 
<M>G \to \mathrm{Inn}(G), a \mapsto \wedge a</M> 
preserves multiplication. 
Indeed, when <M>a=(o,g,p), b=(p,h,r) \in G</M> with objects <M>p,q,r</M> 
all distict, then 
<Display>
\wedge(ab) ~=~ (\wedge a)(\wedge b)(\wedge a) 
           ~=~ (\wedge b)(\wedge a)(\wedge b).  
</Display>
(Compare this with the permutation identity 
<M>(pq)(qr)(pq) = (pr) = (qr)(pq)(qr)</M>.) 
So the map <M>G \to \mathrm{Inn}(G)</M> is of type  
<C>IsMappingWithObjectsByFunction</C>. 
<P/> 
In the example we convert the automorphism group <C>AGa4</C> 
into a single object groupoid, and then define the inner automorphism map. 
<P/>
<Example>
<![CDATA[
gap> AGa40 := Groupoid( AGa4, [0] );
single piece groupoid: < Aut(Ga4), [ 0 ] >
gap> conj := function(a) 
>            return ArrowNC( true, GroupoidInnerAutomorphism(Ga4,a), 0, 0 ); 
>            end;; 
gap> inner := MappingWithObjectsByFunction( Ga4, AGa40, conj, [0,0,0] );;
gap> a1 := Arrow( Ga4, (1,2,3), -15, -13 );;
gap> inn1 := ImageElm( inner, a1 );;                        
gap> a2 := Arrow( Ga4, (2,3,4), -13, -11 );;
gap> inn2 := ImageElm( inner, a2 );;       
gap> a3 := a1*a2;                      
[(1,3)(2,4) : -15 -> -11]
gap> inn3 := ImageElm( inner, a3 );  
[groupoid homomorphism : Ga4 -> Ga4
[ [ [(1,2,3) : -15 -> -15], [(2,3,4) : -15 -> -15], [() : -15 -> -13], 
      [() : -15 -> -11] ], 
  [ [(1,3,4) : -11 -> -11], [(1,2,4) : -11 -> -11], [(1,3)(2,4) : -11 -> -13],
      [() : -11 -> -15] ] ] : 0 -> 0]
gap> (inn3 = inn1*inn2*inn1) and (inn3 = inn2*inn1*inn2);
true
]]>
</Example>

</Subsection>


<ManSection>
   <Oper Name="GroupoidAutomorphismByGroupAutos"
         Arg="gpd, auts" />
<Description>
Homogeneous, discrete groupoids are the second type of groupoid for which a method is provided for <C>AutomorphismGroupOfGroupoid</C>. 
This is used in the <Package>XMod</Package> package for constructing 
crossed modules of groupoids. 
The two types of generating automorphism are 
<C>GroupoidAutomorphismByGroupAutos</C>, which requires a list 
of group automorphisms, one for each object group, 
and <C>GroupoidAutomorphismByObjectPerm</C>, which permutes the objects.  
<P/> 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Hs3 := HomogeneousDiscreteGroupoid( s3, [ -13..-10] ); 
homogeneous, discrete groupoid: < s3, [ -13 .. -10 ] >
gap> aut4 := GroupoidAutomorphismByObjectPerm( Hs3, [-12,-10,-11,-13] ); 
groupoid homomorphism : morphism from a homogeneous discrete groupoid:
[ -13, -12, -11, -10 ] -> [ -12, -10, -11, -13 ]
object homomorphisms:
IdentityMapping( s3 )
IdentityMapping( s3 )
IdentityMapping( s3 )
IdentityMapping( s3 )
gap> gens3 := GeneratorsOfGroup( s3 );; 
gap> g1 := gens3[1];; 
gap> g2 := gens3[2];; 
gap> b1 := GroupHomomorphismByImages( s3, s3, gens3, [g1, g2^g1 ] );; 
gap> b2 := GroupHomomorphismByImages( s3, s3, gens3, [g1^g2, g2 ] );; 
gap> b3 := GroupHomomorphismByImages( s3, s3, gens3, [g1^g2, g2^(g1*g2) ] );; 
gap> b4 := GroupHomomorphismByImages( s3, s3, gens3, [g1^(g2*g1), g2^g1 ] );; 
gap> aut5 := GroupoidAutomorphismByGroupAutos( Hs3, [b1,b2,b3,b4] ); 
groupoid homomorphism : morphism from a homogeneous discrete groupoid:
[ -13, -12, -11, -10 ] -> [ -13, -12, -11, -10 ]
object homomorphisms:
GroupHomomorphismByImages( s3, s3, 
[ (15,17,19)(16,18,20), (15,20)(16,19)(17,18) ], 
[ (15,17,19)(16,18,20), (15,18)(16,17)(19,20) ] )
GroupHomomorphismByImages( s3, s3, 
[ (15,17,19)(16,18,20), (15,20)(16,19)(17,18) ], 
[ (15,19,17)(16,20,18), (15,20)(16,19)(17,18) ] )
GroupHomomorphismByImages( s3, s3, 
[ (15,17,19)(16,18,20), (15,20)(16,19)(17,18) ], 
[ (15,19,17)(16,20,18), (15,16)(17,20)(18,19) ] )
GroupHomomorphismByImages( s3, s3, 
[ (15,17,19)(16,18,20), (15,20)(16,19)(17,18) ], 
[ (15,19,17)(16,20,18), (15,18)(16,17)(19,20) ] )
gap> genAHs3 := GeneratorsOfGroup( AHs3 );;
gap> Length( genAHs3 ); 
4  
gap> ids3 := IdentityMapping( s3 );; 
gap> aut5 := GroupoidAutomorphismByGroupAutos( Hs3, [b1^2,ids3,ids3,ids3] );; 
gap> aut6 := GroupoidAutomorphismByGroupAutos( Hs3, [b2,ids3,ids3,ids3] );; 
gap> aut7 := GroupoidAutomorphismByObjectPerm( Hs3, [ -12, -11, -10, -13 ] );; 
gap> aut8 := GroupoidAutomorphismByObjectPerm( Hs3, [ -12, -13, -11, -10 ] );; 
gap> ok := ForAll( genAHs3, a -> a in[ aut5, aut6, aut7, aut8 ] ); 
true
gap> nobAHs3 := NiceObject( AHs3 );; 
gap> nmonAHs3 := NiceMonomorphism( AHs3 );;
gap> w := genAHs3[1];; 
gap> w1 := ImageElm( nmonAHs3, w );; 
gap> x := genAHs3[2];; 
gap> x1 := ImageElm( nmonAHs3, x );; 
gap> y := genAHs3[3];; 
gap> y1 := ImageElm( nmonAHs3, y );; 
gap> z := genAHs3[4];; 
gap> z1 := ImageElm( nmonAHs3, z );; 
gap> u := z*w*y*x*z; 
groupoid homomorphism : morphism from a homogeneous discrete groupoid:
[ -13, -12, -11, -10 ] -> [ -11, -13, -10, -12 ]
object homomorphisms:
IdentityMapping( s3 )
ConjugatorAutomorphism( s3, (15,19,17)(16,20,18) )
IdentityMapping( s3 )
ConjugatorAutomorphism( s3, (15,20)(16,19)(17,18) )
gap> u1 := z1*w1*y1*x1*z1; 
(1,2,4,3)(5,17,23,16,8,20,26,13)(6,18,24,15,7,19,25,14)(9,21,27,12,10,22,28,
11)
gap> imu := ImageElm( nmonAHs3, u );; 
gap> u1 = imu;
true
]]>
</Example>
<P/>


<ManSection>
   <Attr Name="AutomorphismGroupoidOfGroupoid"
         Arg="gpd" />
<Description>
If <M>G</M> is a single piece groupoid with automorphism group 
<M>\Aut(G)</M>, and if <M>H</M> is the union of <M>k</M> pieces, 
all isomorphic to <M>G</M>, then the automorphism group of <M>H</M> 
is the wreath product <M>S_k \ltimes \Aut(G)</M>. 
However, we find it more convenient to construct 
the <E>automorphism groupoid</E> of <M>H</M>. 
This is a single piece groupoid <M>\Aut(H)</M> 
with <M>k</M> objects -- the object lists of the pieces of <M>H</M> -- 
and root group <M>\Aut(G)</M>. 
Isomorphisms between the root groups of the <M>k</M> pieces 
may be applied to the generators of <M>\Aut(G)</M> 
to construct automorphism groups of these pieces, 
and then isomorphisms between these automorphism groups. 
We then construct <M>\AUT(H)</M> using <C>GroupoidByIsomorphisms</C>. 
<P/> 
In the special case that <M>H</M> is homogeneous, there is no need to construct 
a collection of automorphism groups. Rather, the rays of <M>\AUT(H)</M> 
are given by <C>IsomorphismNewObjects</C>.  
For the example we use <C>Hd8</C> 
constructed in subsection <Ref Oper="HomogeneousGroupoid"/>. 
<P/> 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Hd8 := HomogeneousGroupoid( Gd8,
>           [ [-20,-19,-18], [-12,-11,-10], [-16,-15,-14] ] );;
gap> AHd8 := AutomorphismGroupoidOfGroupoid( Hd8 ); 
gap> ObjectList( AHd8 );
[ [ -20, -19, -18 ], [ -16, -15, -14 ], [ -12, -11, -10 ] ]
gap> RaysOfGroupoid( AHd8 ){[2..3]};
[ groupoid homomorphism : 
    [ [ [(1,2,3,4) : -20 -> -20], [(1,3) : -20 -> -20], [() : -20 -> -19], 
          [() : -20 -> -18] ], 
      [ [(1,2,3,4) : -16 -> -16], [(1,3) : -16 -> -16], [() : -16 -> -15], 
          [() : -16 -> -14] ] ], groupoid homomorphism : 
    [ [ [(1,2,3,4) : -20 -> -20], [(1,3) : -20 -> -20], [() : -20 -> -19], 
          [() : -20 -> -18] ], 
      [ [(1,2,3,4) : -12 -> -12], [(1,3) : -12 -> -12], [() : -12 -> -11], 
          [() : -12 -> -10] ] ] ]
gap> ObjectGroup( AHd8, [ -12, -11, -10 ] );
<group with 8 generators>
]]>
</Example>
<P/>

</Section>



<Section Label="sec-mxreps">
<Heading>Matrix representations of groupoids</Heading>

<Index Key="matrix representation"> matrix representation </Index> 
<Index Key="representation by matrices"> representation by matrices</Index> 
Suppose that <C>gpd</C> is the direct product of a group <M>G</M> 
and a complete digraph, and that <M>\rho : G \to M</M> 
is an isomorphism to a matrix group <M>M</M>. 
Then if <C>rep</C> is the isomorphic groupoid with the same objects 
and root group <M>M</M> there is an isomorphism <M>\mu</M> 
from <C>gpd</C> to <C>rep</C> mapping <M>(g : i \to j)</M> 
to <M>(\rho g : i \to j)</M>. 
<P/> 
When <C>gpd</C> is a groupoid with rays, a representation can be obtained 
by restricting a representation of its parent.
<P/>
<Example>
<![CDATA[
gap> reps := IrreducibleRepresentations( s4 );;
gap> rep4 := reps[4];; 
gap> Rs4 := Groupoid( Image( rep4 ), ObjectList( Gs4 ) ); 
single piece groupoid: < Group([ [ [ 0, 1, 0 ], [ 1, 0, 0 ], [ 0, 0, 1 ] ], 
  [ [ 0, 0, 1 ], [ 1, 0, 0 ], [ 0, 1, 0 ] ], 
  [ [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, -1 ] ], 
  [ [ 1, 0, 0 ], [ 0, -1, 0 ], [ 0, 0, -1 ] ] ]), [ -15, -14, -13, -12, -11 
 ] >
gap> IsMatrixGroupoid( Rs4 ); 
true
gap> gens := GeneratorsOfGroupoid( Gs4 );
[ [(1,2,3,4) : -15 -> -15], [(3,4) : -15 -> -15], [() : -15 -> -14], 
  [() : -15 -> -13], [() : -15 -> -12], [() : -15 -> -11] ]
gap> images := List( gens, 
>        g -> Arrow( Rs4, ImageElm(rep4,g![1]), g![2], g![3] ) ); 
[ [[ [ -1, 0, 0 ], [ 0, 0, 1 ], [ 0, -1, 0 ] ] : -15 -> -15], 
  [[ [ 0, 1, 0 ], [ 1, 0, 0 ], [ 0, 0, 1 ] ] : -15 -> -15], 
  [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -14], 
  [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -13], 
  [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -12], 
  [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -11] ]
gap> mor := GroupoidHomomorphismFromSinglePiece( Gs4, Rs4, gens, images );
groupoid homomorphism : 
[ [ [(1,2,3,4) : -15 -> -15], [(3,4) : -15 -> -15], [() : -15 -> -14], 
      [() : -15 -> -13], [() : -15 -> -12], [() : -15 -> -11] ], 
  [ [[ [ -1, 0, 0 ], [ 0, 0, 1 ], [ 0, -1, 0 ] ] : -15 -> -15], 
      [[ [ 0, 1, 0 ], [ 1, 0, 0 ], [ 0, 0, 1 ] ] : -15 -> -15], 
      [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -14], 
      [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -13], 
      [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -12], 
      [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -11] ] ]
gap> a := Arrow( Hs4, (1,4,2), -12, -13 );
[(1,4,2) : -12 -> -13]
gap> ImageElm( mor, a );
[[ [ 0, 0, -1 ], [ -1, 0, 0 ], [ 0, 1, 0 ] ] : -12 -> -13]
gap> rmor := RestrictedMappingGroupoids( mor, Hd8b );
groupoid homomorphism : 
[ [ [(1,2,3,4) : -14 -> -14], [(1,3) : -14 -> -14], [(1,2,3) : -14 -> -13], 
      [(1,2,4) : -14 -> -12] ], 
  [ [[ [ -1, 0, 0 ], [ 0, 0, 1 ], [ 0, -1, 0 ] ] : -14 -> -14], 
      [[ [ 1, 0, 0 ], [ 0, 0, -1 ], [ 0, -1, 0 ] ] : -14 -> -14], 
      [[ [ 0, 0, 1 ], [ -1, 0, 0 ], [ 0, -1, 0 ] ] : -14 -> -13], 
      [[ [ 0, -1, 0 ], [ 0, 0, 1 ], [ -1, 0, 0 ] ] : -14 -> -12] ] ]
]]>
</Example>
<P/>

</Section>

</Chapter>

<?xml version="1.0" encoding="UTF-8"?> 

<Chapter Label="chap-gpdaut">
<Heading>Automorphisms of Groupoids</Heading>

In this chapter we consider automorphisms of single piece groupoids; 
then homogeneous discrete groupoids; and finally homogeneous groupoids. 
We also consider matrix representations and groupooid actions.

<Section Label="sec-autos-single">
<Heading>Automorphisms of single piece groupoids</Heading>

<ManSection>
   <Oper Name="GroupoidAutomorphismByObjectPerm"
         Arg="gpd, imobs" />
   <Oper Name="GroupoidAutomorphismByGroupAuto"
         Arg="gpd, gpiso" />
   <Oper Name="GroupoidAutomorphismByNtuple"
         Arg="gpd, imrays" />
   <Oper Name="GroupoidAutomorphismByRayShifts"
         Arg="gpd, imrays" />
<Description>
We first describe automorphisms of a groupoid <M>G</M> where 
<M>G</M> is the direct product of a group <M>g</M> 
and a complete digraph with <M>n</M> objects.. 
The automorphism group is generated by three types of automorphism: 
<List>
<Item>
given a permutation <M>\pi</M> of the <M>n</M> objects, we define 
<Display>
\alpha_{\pi} : G \to G,~ 
(g : o_i \to o_j) \mapsto (g : o_{\pi i} \to o_{\pi j});
</Display> 
</Item>
<Item>
given an automorphism <M>\theta</M> of the root group <M>g</M>, we define 
<Display>
\alpha_{\theta} : G \to G,~ (g : o_i \to o_j) \mapsto (\theta g : o_i \to o_j);
</Display>
</Item>
<Item>
given <M>L = [g_1,g_2,g_3,\ldots,g_n] \in g^n</M> we define 
<Display>
\alpha_L : G \to G,~ (g : o_i \to o_j) \mapsto (g_i^{-1}gg_j : o_i \to o_j).
</Display> 
If <M>g_1 = 1_g</M>, then for all <M>j</M> 
the rays <M>(r_j : o_1 \to o_j)</M> are shifted by <M>g_j\;</M>: 
so they map to <M>(r_jg_j : o_1 \to o_j)</M>.
So the operation <C>GroupoidAutomorphismByRayShifts</C> is the special case 
of <C>GroupoidAutomorphismByNtuple</C> when <M>g_1=1</M>.
</Item>
</List> 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> perm1 := [-13,-12,-14];;
gap> aut1 := GroupoidAutomorphismByObjectPerm( Ha4, perm1 );; 
gap> Display( aut1 ); 
homomorphism to single piece groupoid: Ha4 -> Ha4
root group homomorphism:
(1,2,3) -> (1,2,3)
(2,3,4) -> (2,3,4)
object map: [ -14, -13, -12 ] -> [ -13, -12, -14 ]
ray images: [ (), (), () ]
gap> d := Arrow( Ha4, (1,3,4), -12, -13 ); 
[(1,3,4) : -12 -> -13]
gap> d1 := ImageElm( aut1, d ); 
[(1,3,4) : -14 -> -12]
gap> gensa4 := GeneratorsOfGroup( a4 );; 
gap> alpha2 := GroupHomomorphismByImages( a4, a4, gensa4, [(2,3,4), (1,3,4)] );; 
gap> aut2 := GroupoidAutomorphismByGroupAuto( Ha4, alpha2 );; 
gap> Display( aut2 ); 
homomorphism to single piece groupoid: Ha4 -> Ha4
root group homomorphism:
(1,2,3) -> (2,3,4)
(2,3,4) -> (1,3,4)
object map: [ -14, -13, -12 ] -> [ -14, -13, -12 ]
ray images: [ (), (), () ]
gap> d2 := ImageElm( aut2, d1 );
[(1,2,4) : -14 -> -12]
gap> L3 := [(1,2)(3,4), (1,3)(2,4), (1,4)(2,3)];; 
gap> aut3 := GroupoidAutomorphismByNtuple( Ha4, L3 );; 
gap> Display( aut3 ); 
homomorphism to single piece groupoid: Ha4 -> Ha4
root group homomorphism:
(1,2,3) -> (1,4,2)
(2,3,4) -> (1,4,3)
object map: [ -14, -13, -12 ] -> [ -14, -13, -12 ]
ray images: [ (), (1,4)(2,3), (1,3)(2,4) ]
gap> d3 := ImageElm( aut3, d2 );
[(2,3,4) : -14 -> -12]
gap> L4 := [(), (1,3,2), (2,4,3)];; 
gap> aut4 := GroupoidAutomorphismByRayShifts( Ha4, L4 );; 
gap> Display( aut4 ); 
homomorphism to single piece groupoid: Ha4 -> Ha4
root group homomorphism:
(1,2,3) -> (1,2,3)
(2,3,4) -> (2,3,4)
object map: [ -14, -13, -12 ] -> [ -14, -13, -12 ]
ray images: [ (), (1,3,2), (2,4,3) ]
gap> d4 := ImageElm( aut4, d3 );
[() : -14 -> -12]
gap> h4 := Arrow( Ha4, (2,3,4), -12, -13 );; 
gap> aut1234 := aut1*aut2*aut3*aut4;; 
gap> Display( aut1234 ); 
homomorphism to single piece groupoid: Ha4 -> Ha4
root group homomorphism:
(1,2,3) -> (1,4,3)
(2,3,4) -> (1,2,3)
object map: [ -14, -13, -12 ] -> [ -13, -12, -14 ]
ray images: [ (), (2,3,4), (1,3,4) ]
gap> d4  = ImageElm( aut1234, d );
true
gap> inv1234 := InverseGeneralMapping( aut1234 );; 
gap> Display( inv1234 ); 
homomorphism to single piece groupoid: Ha4 -> Ha4
root group homomorphism:
(1,2,3) -> (1,4,3)
(2,3,4) -> (2,4,3)
object map: [ -14, -13, -12 ] -> [ -12, -14, -13 ]
ray images: [ (), (1,3,2), (1,3,4) ]
]]>
</Example>

<ManSection>
   <Oper Name="GroupoidInnerAutomorphism" 
         Arg="gpd, arrow" />
   <Oper Name="GroupoidInnerAutomorphism" 
         Arg="gpd, subgpd, arrow" />
<Description>
<Index>inner automorphism</Index> 
Given an arrow <M>a = (c : p \to q) \in G</M> with <M>p \neq q</M>, 
the <E>inner automorphism</E> <M>\alpha_a</M> of <M>G</M> by <M>a</M> 
is the mapping <M>g \mapsto g^a</M> 
where conjugation of arrows is defined in section <Ref Sect="sec-conj"/>.
It is easily checked that if 
<M>L_a = [1,\ldots,1,c^{-1},1,\ldots,1,c,1,\ldots,1]</M>, with 
<M>c^{-1}</M> in position <M>p</M> and <M>c</M> in position <M>q</M>, then
<Display>
\alpha_a ~=~ \alpha_{(p,q)} * \alpha_{L_a}.
</Display>
Similarly, when <M>p=q</M>, then <M>\alpha_a = \alpha_{L_a}</M>
where now <M> L_a = [1,\ldots,1,c,1,\ldots,1]</M>,
with <M>c</M> in position <M>p</M>.
</Description>
</ManSection>
<Example>
<![CDATA[
gap> inn1 := GroupoidInnerAutomorphism( Ha4, h4 );;
gap> Display( inn1 );
homomorphism to single piece groupoid: Ha4 -> Ha4
root group homomorphism:
(1,2,3) -> (1,2,3)
(2,3,4) -> (2,3,4)
object map: [ -14, -13, -12 ] -> [ -14, -12, -13 ]
ray images: [ (), (2,4,3), (2,3,4) ]
gap> d5 := ImageElm( inn1, d4 );
[(2,3,4) : -14 -> -13]
]]>
</Example>

Conjugation may also be applied to certain normal subgroupoids of <M>G</M>.
Firstly, let <M>N</M> be the wide subgroupoid of <M>G</M> determined by
a normal subgroup <M>n</M> of the root group.
Then, provided the group element of <M>a</M> is in <M>n</M>, 
the inner automorphism by <M>a</M> may be applied to <M>N</M>.
<P/>
<Example>
<![CDATA[
gap> Nk4 := SubgroupoidBySubgroup( Ha4, k4 );;
gap> SetName( Nk4, "Nk4" );
gap> e4 := Arrow( Ha4, (1,2)(3,4), -14, -13 );;
gap> inn2 := GroupoidInnerAutomorphism( Ha4, Nk4, e4 );;
gap> Display( inn2 );
homomorphism to single piece groupoid: Nk4 -> Nk4
root group homomorphism:
(1,2)(3,4) -> (1,2)(3,4)
(1,3)(2,4) -> (1,3)(2,4)
object map: [ -14, -13, -12 ] -> [ -13, -14, -12 ]
ray images: [ (), (), (1,2)(3,4) ]
]]>
</Example>

Secondly, if <M>H</M> is a homogeneous, discrete subgroupoid of <M>G</M>
and if the group element of <M>a</M> is in the common vertex groups,
then the inner automorphism may be applied to <M>H</M>.
<P/>
<Example>
<![CDATA[
gap> Ma4 := MaximalDiscreteSubgroupoid( Ha4 );;
gap> SetName( Ma4, "Ma4" );
gap> inn3 := GroupoidInnerAutomorphism( Ha4, Ma4, e4 );;
gap> Display( inn3 );
homogeneous discrete groupoid mapping: [ Ma4 ] -> [ Ma4 ]
images of objects: [ -13, -14, -12 ]
object homomorphisms:
GroupHomomorphismByImages( a4, a4, [ (1,2,3), (2,3,4) ], [ (1,4,2), (1,4,3)  ] )
GroupHomomorphismByImages( a4, a4, [ (1,2,3), (2,3,4) ], [ (1,4,2), (1,4,3)  ] )
GroupHomomorphismByImages( a4, a4, [ (1,2,3), (2,3,4) ], [ (1,2,3), (2,3,4)  ] )
]]>
</Example>




<Subsection Label="subsec-autos-with-rays">
<Heading>Automorphisms of a groupoid with rays</Heading>

Let <M>S</M> be a wide subgroupoid with rays of a standard groupoid <M>G</M>. 
<P/> 
An automorphism <M>\alpha</M> of the root group <M>H</M>
extends to the whole of <M>S</M> with the rays fixed by the automorphism:
<M>(r^{-1}_ihr_j : o_i \to o_j) 
\mapsto (r^{-1}_i (\alpha h)r_j : o_i \to o_j)</M>.
<P/> 
An automorphism of <M>G</M> obtained by permuting the objects 
may map <M>S</M> to a different subgroupoid.  
So we construct an isomorphism <M>\iota</M> from <M>S</M> 
to a standard groupoid <M>T</M>, construct <M>\alpha</M> 
permuting the objects of <M>T</M>, and return <M>\iota*\alpha*\iota^{-1}</M>.  
<P/>
For an automorphism by ray shifts we require that the shifts are 
elements of the root group of <M>S</M>. 
<P/>
<Example>
<![CDATA[
gap> ## (1) automorphism by group auto 
gap> a6 := GroupHomomorphismByImages( k4, k4,
>              [ (1,2)(3,4), (1,3)(2,4) ], [ (1,3)(2,4), (1,4)(2,3) ] );;
gap> aut6 := GroupoidAutomorphismByGroupAuto( Kk4, a6 );
groupoid homomorphism : Kk4 -> Kk4
[ [ [(1,2)(3,4) : -14 -> -14], [(1,3)(2,4) : -14 -> -14], 
      [(1,3,4) : -14 -> -13], [(1,4)(2,3) : -14 -> -12] ], 
  [ [(1,3)(2,4) : -14 -> -14], [(1,4)(2,3) : -14 -> -14], 
      [(1,3,4) : -14 -> -13], [(1,4)(2,3) : -14 -> -12] ] ]
gap> a := Arrow( Kk4, (1,3)(2,4), -12, -12 );;
gap> ImageElm( aut6, a );
[(1,4)(2,3) : -12 -> -12]
gap> b := Arrow( Kk4, (1,4,2), -12, -13 );;
gap> ImageElm( aut6, b );
[(1,2,3) : -12 -> -13]
gap> ## (2) automorphism by object perm 
gap> aut7 := GroupoidAutomorphismByObjectPerm( Kk4, [-13,-12,-14] );
groupoid homomorphism : Kk4 -> Kk4
[ [ [(1,2)(3,4) : -14 -> -14], [(1,3)(2,4) : -14 -> -14], 
      [(1,3,4) : -14 -> -13], [(1,4)(2,3) : -14 -> -12] ], 
  [ [(1,4)(2,3) : -13 -> -13], [(1,2)(3,4) : -13 -> -13], 
      [(2,3,4) : -13 -> -12], [(1,4,3) : -13 -> -14] ] ]
gap> ImageElm( aut7, a );                                           
[(1,3)(2,4) : -14 -> -14]
gap> ImageElm( aut7, b );                                           
[(1,3)(2,4) : -14 -> -12]
gap> ## (3) automorphism by ray shifts 
gap> aut8 := GroupoidAutomorphismByRayShifts( Kk4,
>                [ (), (1,4)(2,3), (1,3)(2,4) ] );
groupoid homomorphism : Kk4 -> Kk4
[ [ [(1,2)(3,4) : -14 -> -14], [(1,3)(2,4) : -14 -> -14], 
      [(1,3,4) : -14 -> -13], [(1,4)(2,3) : -14 -> -12] ], 
  [ [(1,2)(3,4) : -14 -> -14], [(1,3)(2,4) : -14 -> -14], 
      [(1,2,3) : -14 -> -13], [(1,2)(3,4) : -14 -> -12] ] ]
gap> ImageElm( aut8, a );
[(1,3)(2,4) : -12 -> -12]
gap> ImageElm( aut8, b );
[(1,2,3) : -12 -> -13]
gap> ## (4) combine these three automorphisms 
gap> aut678 := aut6 * aut7 * aut8;
groupoid homomorphism : Kk4 -> Kk4
[ [ [(1,2)(3,4) : -14 -> -14], [(1,3)(2,4) : -14 -> -14], 
      [(1,3,4) : -14 -> -13], [(1,4)(2,3) : -14 -> -12] ], 
  [ [(1,2)(3,4) : -13 -> -13], [(1,3)(2,4) : -13 -> -13], 
      [(1,4,3) : -13 -> -12], [(1,3,2) : -13 -> -14] ] ]
gap> ImageElm( aut678, a ); 
[(1,4)(2,3) : -14 -> -14]
gap> ImageElm( aut678, b );
[(1,4)(2,3) : -14 -> -12]
gap> ## (5) conjgation by an arrow
gap> e8 := Arrow( Kk4, (1,3)(2,4), -14, -12 );;
gap> aut9 := GroupoidInnerAutomorphism( Kk4, e8 );
groupoid homomorphism : Kk4 -> Kk4
[ [ [(1,2)(3,4) : -14 -> -14], [(1,3)(2,4) : -14 -> -14], 
      [(1,3,4) : -14 -> -13], [(1,4)(2,3) : -14 -> -12] ], 
  [ [(1,2)(3,4) : -12 -> -12], [(1,3)(2,4) : -12 -> -12], 
      [(1,4,2) : -12 -> -13], [(1,4)(2,3) : -12 -> -14] ] ]
]]>
</Example>
</Subsection>


<ManSection>
   <Oper Name="AutomorphismGroupOfGroupoid"
         Arg="gpd" />
   <Oper Name="NiceObjectAutoGroupGroupoid"
         Arg="gpd, aut" />
<Description>
As above, let <M>G</M> be the direct product of a group <M>g</M> 
and a complete digraph with <M>n</M> objects. 
The <Index Key="AutomorphismGroup"> <C>AutomorphismGroup</C> </Index> 
<C>AutomorphismGroup</C> <M>\Aut(G)</M> of <M>G</M> is isomorphic to 
the quotient of <M>S_n \times A \times g^n</M> 
by a subgroup isomorphic to <M>g</M>, 
where <M>A</M> is the automorphism group of <M>g</M> 
and <M>S_n</M> is the symmetric group on the <M>n</M> objects. 
This is one of the main topics in <Cite Key="AlWe" />. 
<P/> 
If <M>H</M> is the union of <M>k</M> groupoids, all isomorphic to <M>G</M>, 
then <M>\Aut(H)</M> is isomorphic to <M>S_k \ltimes \Aut(G)</M>. 
<P/>
The function <C>NiceObjectAutoGroupGroupoid</C> takes a groupoid 
and a subgroup of its automorphism group and retuns a 
<E>nice monomorphism</E> from this automorphism group to a pc-group, 
if one is available.  
The current implementation is experimental. 
Note that <C>ImageElm</C> at present only works on generating elements.  
<P/> 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> AHa4 := AutomorphismGroupOfGroupoid( Ha4 ); 
Aut(Ha4)
gap> Agens := GeneratorsOfGroup( AHa4);; 
gap> Length( Agens );
8
gap> NHa4 := NiceObject( AHa4 );; 
gap> MHa4 := NiceMonomorphism( AHa4 );; 
gap> Size( AHa4 );    ## (3!)x24x(12^2)
20736
gap> SetName( AHa4, "AHa4" ); 
gap> SetName( NHa4, "NHa4" );
gap> ## either of these names may be returned
gap> names := [ "(((A4 x A4 x A4) : C2) : C3) : C2",
>    "(C2 x C2 x C2 x C2 x C2 x C2) : (((C3 x C3 x C3) : C3) : (C2 x C2))" ];;
gap> StructureDescription( NHa4 ) in names;
true
gap> ##  cannot test images of Agens because of random variations 
gap> ##  Now do some tests!
gap> mgi := MappingGeneratorsImages( MHa4 );; 
gap> autgen := mgi[1];;
gap> pcgen := mgi[2];;
gap> ngen := Length( autgen );; 
gap> ForAll( [1..ngen], i -> Order(autgen[i]) = Order(pcgen[i]) ); 
true
]]>
</Example>


<Subsection Label="subsec-inner-autos">
<Heading>Inner automorphisms</Heading>

The inner automorphism subgroup <M>\mathrm{Inn}(G)</M> 
<Index Key="inner automorphism group"> inner automorphism group </Index> 
of the automorphism group of <M>G</M> is the group of inner automorphisms 
<M>\wedge a : b \mapsto b^a</M> for <M>a \in G</M>. 
It is <E>not</E> the case that the map 
<M>G \to \mathrm{Inn}(G), a \mapsto \wedge a</M> 
preserves multiplication. 
Indeed, when <M>a=(o,g,p), b=(p,h,r) \in G</M> with objects <M>p,q,r</M> 
all distict, then 
<Display>
\wedge(ab) ~=~ (\wedge a)(\wedge b)(\wedge a) 
           ~=~ (\wedge b)(\wedge a)(\wedge b).  
</Display>
(Compare this with the permutation identity 
<M>(pq)(qr)(pq) = (pr) = (qr)(pq)(qr)</M>.) 
So the map <M>G \to \mathrm{Inn}(G)</M> is of type  
<C>IsMappingWithObjectsByFunction</C>. 
<P/> 
In the example we convert the automorphism group <C>AGa4</C> 
into a single object groupoid, and then define the inner automorphism map. 
<P/>
<Example>
<![CDATA[
gap> AHa40 := Groupoid( AHa4, [0] );
single piece groupoid: < Aut(Ha4), [ 0 ] >
gap> conj := function(a) 
>        return ArrowNC( Ha4, true, GroupoidInnerAutomorphism(Ha4,a), 0, 0 ); 
>    end;; 
gap> inner := MappingWithObjectsByFunction( Ha4, AHa40, conj, [0,0,0] );;
gap> a1 := Arrow( Ha4, (1,2,3), -14, -13 );;
gap> inner1 := ImageElm( inner, a1 );;                        
gap> a2 := Arrow( Ha4, (2,3,4), -13, -12 );;
gap> inner2 := ImageElm( inner, a2 );;       
gap> a3 := a1*a2;                      
[(1,3)(2,4) : -14 -> -12]
gap> inner3 := ImageElm( inner, a3 );  
[groupoid homomorphism : Ha4 -> Ha4
[ [ [(1,2,3) : -14 -> -14], [(2,3,4) : -14 -> -14], [() : -14 -> -13], 
      [() : -14 -> -12] ], 
  [ [(1,3,4) : -12 -> -12], [(1,2,4) : -12 -> -12], [(1,3)(2,4) : -12 -> -13],
      [() : -12 -> -14] ] ] : 0 -> 0]
gap> (inner3 = inner1*inner2*inner1) and (inner3 = inner2*inner1*inner2);
true
true
]]>
</Example>

</Subsection>


<ManSection>
   <Oper Name="GroupoidAutomorphismByGroupAutos"
         Arg="gpd, auts" />
<Description>
Homogeneous, discrete groupoids are the second type of groupoid for which a method is provided for <C>AutomorphismGroupOfGroupoid</C>. 
This is used in the <Package>XMod</Package> package for constructing 
crossed modules of groupoids. 
The two types of generating automorphism are 
<C>GroupoidAutomorphismByGroupAutos</C>, which requires a list 
of group automorphisms, one for each object group, 
and <C>GroupoidAutomorphismByObjectPerm</C>, which permutes the objects. 
So, if the object groups <M>g</M> have automorphism group <M>\Aut(g)</M>
and there are <M>n</M> objects, the autmorphism group of the groupoid
has size <M>n!|\Aut(g)|^n</M>.
<P/> 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Dd8 := HomogeneousDiscreteGroupoid( d8, [ -13..-10] ); 
homogeneous, discrete groupoid: < d8, [ -13 .. -10 ] >
gap> aut10 := GroupoidAutomorphismByObjectPerm( Dd8, [-12,-10,-11,-13] ); 
groupoid homomorphism : morphism from a homogeneous discrete groupoid:
[ -13, -12, -11, -10 ] -> [ -12, -10, -11, -13 ]
object homomorphisms:
IdentityMapping( d8 )
IdentityMapping( d8 )
IdentityMapping( d8 )
IdentityMapping( d8 )
gap> gend8 := GeneratorsOfGroup( d8 );; 
gap> g1 := gend8[1];; 
gap> g2 := gend8[2];;
gap> b1 := IdentityMapping( d8 );;
gap> b2 := GroupHomomorphismByImages( d8, d8, gend8, [g1, g2*g1 ] );; 
gap> b3 := GroupHomomorphismByImages( d8, d8, gend8, [g1^g2, g2 ] );; 
gap> b4 := GroupHomomorphismByImages( d8, d8, gend8, [g1^g2, g2^(g1*g2) ] );; 
gap> aut11 := GroupoidAutomorphismByGroupAutos( Dd8, [b1,b2,b3,b4] ); 
groupoid homomorphism : morphism from a homogeneous discrete groupoid:
[ -13, -12, -11, -10 ] -> [ -13, -12, -11, -10 ]
object homomorphisms:
IdentityMapping( d8 )
GroupHomomorphismByImages( d8, d8, [ (5,6,7,8), (5,7) ], 
[ (5,6,7,8), (5,8)(6,7) ] )
GroupHomomorphismByImages( d8, d8, [ (5,6,7,8), (5,7) ], [ (5,8,7,6), (5,7) ] )
GroupHomomorphismByImages( d8, d8, [ (5,6,7,8), (5,7) ], [ (5,8,7,6), (6,8) ] )
gap> ADd8 := AutomorphismGroupOfGroupoid( Dd8 ); 
<group with 4 generators>
gap> Size( ADd8 );    ## 4!*8^4
98304
gap> genADd8 := GeneratorsOfGroup( ADd8 );;
gap> Length( genADd8 ); 
4  
gap> w := GroupoidAutomorphismByGroupAutos( Dd8, [b2,b1,b1,b1] );; 
gap> x := GroupoidAutomorphismByGroupAutos( Dd8, [b3,b1,b1,b1] );; 
gap> y := GroupoidAutomorphismByObjectPerm( Dd8, [ -12, -11, -10, -13 ] );; 
gap> z := GroupoidAutomorphismByObjectPerm( Dd8, [ -12, -13, -11, -10 ] );; 
gap> ok := ForAll( genADd8, a -> a in[ w, x, y, z ] ); 
true
gap> NADd8 := NiceObject( ADd8 );; 
gap> MADd8 := NiceMonomorphism( ADd8 );;
gap> w1 := ImageElm( MADd8, w );; 
gap> x1 := ImageElm( MADd8, x );; 
gap> y1 := ImageElm( MADd8, y );; 
gap> z1 := ImageElm( MADd8, z );; 
gap> u := z*w*y*x*z; 
groupoid homomorphism : morphism from a homogeneous discrete groupoid:
[ -13, -12, -11, -10 ] -> [ -11, -13, -10, -12 ]
object homomorphisms:
IdentityMapping( d8 )
GroupHomomorphismByImages( d8, d8, [ (5,6,7,8), (5,7) ], 
[ (5,6,7,8), (5,8)(6,7) ] )
IdentityMapping( d8 )
GroupHomomorphismByImages( d8, d8, [ (5,6,7,8), (5,7) ], [ (5,8,7,6), (5,7) ] )
gap> u1 := z1*w1*y1*x1*z1; 
(1,2,4,3)(5,17,23,11,6,18,24,16)(7,19,25,15,9,21,27,13)(8,20,26,14,10,22,28,12)
gap> imu := ImageElm( MADd8, u );; 
gap> u1 = imu;
true
]]>
</Example>
<P/>


<ManSection>
   <Attr Name="AutomorphismGroupoidOfGroupoid"
         Arg="gpd" />
<Description>
If <M>G</M> is a single piece groupoid with automorphism group 
<M>\Aut(G)</M>, and if <M>H</M> is the union of <M>k</M> pieces, 
all isomorphic to <M>G</M>, then the automorphism group of <M>H</M> 
is the wreath product <M>S_k \ltimes \Aut(G)</M>. 
However, we find it more convenient to construct 
the <E>automorphism groupoid</E> of <M>H</M>. 
This is a single piece groupoid <M>\AUT(H)</M> with <M>k</M> objects -
the object lists of the pieces of <M>H</M> - and root group <M>\Aut(G)</M>. 
Isomorphisms between the root groups of the <M>k</M> pieces 
may be applied to the generators of <M>\Aut(G)</M> 
to construct automorphism groups of these pieces, 
and then isomorphisms between these automorphism groups. 
We then construct <M>\AUT(H)</M> using <C>GroupoidByIsomorphisms</C>. 
<P/> 
In the special case that <M>H</M> is homogeneous, there is no need to 
construct a collection of automorphism groups. 
Rather, the rays of <M>\AUT(H)</M> are given by <C>IsomorphismNewObjects</C>.  
For the example we use <C>HGd8</C> 
constructed in subsection <Ref Oper="HomogeneousGroupoid"/>. 
<P/> 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> HGd8 := HomogeneousGroupoid( Gd8, 
>                [ [-39,-38,-37], [-36,-35,-34], [-33,-32,-31] ] );;
gap> SetName( HGd8, "HGd8" );
gap> AHGd8 := AutomorphismGroupoidOfGroupoid( HGd8 ); 
Aut(HGd8)
gap> ObjectList( AHGd8 );
[ [ -39, -38, -37 ], [ -36, -35, -34 ], [ -33, -32, -31 ] ]
gap> RaysOfGroupoid( AHGd8 ){[2..3]};
[ groupoid homomorphism : 
    [ [ [(5,6,7,8) : -39 -> -39], [(5,7) : -39 -> -39], [() : -39 -> -38], 
          [() : -39 -> -37] ], 
      [ [(5,6,7,8) : -36 -> -36], [(5,7) : -36 -> -36], [() : -36 -> -35], 
          [() : -36 -> -34] ] ], groupoid homomorphism : 
    [ [ [(5,6,7,8) : -39 -> -39], [(5,7) : -39 -> -39], [() : -39 -> -38], 
          [() : -39 -> -37] ], 
      [ [(5,6,7,8) : -33 -> -33], [(5,7) : -33 -> -33], [() : -33 -> -32], 
          [() : -33 -> -31] ] ] ]
gap> obgp := ObjectGroup( AHGd8, [ -36, -35, -34 ] );; 
gap> Size( obgp );    ## 3!*8^3
3072
]]>
</Example>
<P/>

</Section>



<Section Label="sec-mxreps">
<Heading>Matrix representations of groupoids</Heading>

<Index Key="matrix representation"> matrix representation </Index> 
<Index Key="representation by matrices"> representation by matrices</Index> 
Suppose that <C>gpd</C> is the direct product of a group <M>G</M> 
and a complete digraph, and that <M>\rho : G \to M</M> 
is an isomorphism to a matrix group <M>M</M>. 
Then, if <C>rep</C> is the isomorphic groupoid with the same objects 
and root group <M>M</M>, there is an isomorphism <M>\mu</M> 
from <C>gpd</C> to <C>rep</C> mapping <M>(g : i \to j)</M> 
to <M>(\rho g : i \to j)</M>. 
<P/> 
When <C>gpd</C> is a groupoid with rays, a representation can be obtained 
by restricting a representation of its parent.
<P/>
<Example>
<![CDATA[
gap> reps := IrreducibleRepresentations( a4 );; 
gap> rep4 := reps[4]; 
Pcgs([ (2,4,3), (1,3)(2,4), (1,2)(3,4) ]) -> 
[ [ [ 0, 0, 1 ], [ 1, 0, 0 ], [ 0, 1, 0 ] ], 
  [ [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, -1 ] ], 
  [ [ 1, 0, 0 ], [ 0, -1, 0 ], [ 0, 0, -1 ] ] ]
gap> Ra4 := Groupoid( Image( rep4 ), Ga4!.objects );; 
gap> ObjectList( Ra4 ) = [ -15 .. -11 ];
true
gap> gens := GeneratorsOfGroupoid( Ga4 );
[ [(1,2,3) : -15 -> -15], [(2,3,4) : -15 -> -15], [() : -15 -> -14],
  [() : -15 -> -13], [() : -15 -> -12], [() : -15 -> -11] ]
gap> images := List( gens, 
>        g -> Arrow( Ra4, ImageElm(rep4,g![2]), g![3], g![4] ) ); 
[ [[ [ 0, 0, -1 ], [ 1, 0, 0 ], [ 0, -1, 0 ] ] : -15 -> -15], 
  [[ [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ] ] : -15 -> -15], 
  [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -14], 
  [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -13], 
  [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -12], 
  [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -11] ]
gap> mor := GroupoidHomomorphismFromSinglePiece( Ga4, Ra4, gens, images );
groupoid homomorphism : 
[ [ [(1,2,3) : -15 -> -15], [(2,3,4) : -15 -> -15], [() : -15 -> -14], 
      [() : -15 -> -13], [() : -15 -> -12], [() : -15 -> -11] ], 
  [ [[ [ 0, 0, -1 ], [ 1, 0, 0 ], [ 0, -1, 0 ] ] : -15 -> -15], 
      [[ [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ] ] : -15 -> -15], 
      [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -14], 
      [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -13], 
      [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -12], 
      [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -15 -> -11] ] ]
gap> IsMatrixGroupoid( Ra4 ); 
true
gap> a := Arrow( Ha4, (1,4,2), -12, -13 );
[(1,4,2) : -12 -> -13]
gap> ImageElm( mor, a );
[[ [ 0, 0, 1 ], [ -1, 0, 0 ], [ 0, -1, 0 ] ] : -12 -> -13]
gap> rmor := RestrictedMappingGroupoids( mor, Ha4 );
groupoid homomorphism : 
[ [ [(1,2,3) : -14 -> -14], [(2,3,4) : -14 -> -14], [() : -14 -> -13], 
      [() : -14 -> -12] ], 
  [ [[ [ 0, 0, -1 ], [ 1, 0, 0 ], [ 0, -1, 0 ] ] : -14 -> -14], 
      [[ [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ] ] : -14 -> -14], 
      [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -14 -> -13], 
      [[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] : -14 -> -12] ] ]
gap> ParentMappingGroupoids( rmor ) = mor;
true
]]>
</Example>
<P/>

</Section>

<Section> 
<Heading>Groupoid actions</Heading>
Recall from sections <Ref Sect="sec-conj"/> and
<Ref Oper="GroupoidInnerAutomorphism"/>
the notion of <E>conjugation</E> in a groupoid,
and the associated inner automorphisms.
<P/>
It was mentioned there that the map  
<M>\wedge : G \to \Aut(G),~ a \to \wedge a</M>,
is <E>not</E> a groupoid homomorphism.
It is in fact a <E>groupoid action</E> <Index>groupoid action</Index> 
which we now define.
Let <M>\{p,q,r,u,v\}</M> be distinct objects in <M>G</M> and let: 
<P/>
<M>a_1 = (c_1 : p \to q),~~ a_2 = (c_2 : q \to r),~~
   a_3 = (c_3 : q \to p),~~ a_4 = (c_4 : u \to v)</M>,
<P/>
<M>b_1 = (d_1 : p \to p),~~ b_2 = (d_2 : p \to p),~~
   b_3 = (d_3 : q \to q),~~ b_4 = (c_3c_1 : q \to q)</M>
be arrows in <M>G</M>.

Then the following <E>conjugation identities</E>
must be satisfied: <Index>conjugation identities</Index>
<List>
<Item>
<M>\wedge(a_1a_2) ~=~ (\wedge a_1)*(\wedge a_2)*(\wedge a_1)
                  ~=~ (\wedge a_2)*(\wedge a_1)*(\wedge a_2)</M>,
</Item>
<Item>
<M>\wedge(b_1a_1) ~=~ (\wedge b_1)*(\wedge a_1)*(\wedge b_1)^{-1}</M>,
</Item>
<Item>
<M>\wedge(a_1b_3) ~=~ (\wedge b_3)^{-1}*(\wedge a_1)*(\wedge b_3)</M>,
</Item>
<Item>
<M>\wedge(b_1b_2) ~=~ (\wedge b_1)*(\wedge b_2)</M>,
</Item>
<Item>
<M>\wedge(a_1a_3) ~=~ (\wedge a_1)*(\wedge a_3)*(\wedge b_4)</M>,
</Item>
<Item>
<M>(\wedge a_1)*(\wedge a_4) ~=~ (\wedge a_4)*(\wedge a_1)</M>.
</Item>
</List>
<P/>
In the following example we check the first of these identities
in one particular case.
<Example>
<![CDATA[
gap> c1 := Arrow( Ha4, (1,2)(3,4), -14, -13);;
gap> innc1 := GroupoidInnerAutomorphism( Ha4, c1 );
groupoid homomorphism : Ha4 -> Ha4
[ [ [(1,2,3) : -14 -> -14], [(2,3,4) : -14 -> -14], [() : -14 -> -13], 
      [() : -14 -> -12] ], 
  [ [(1,4,2) : -13 -> -13], [(1,4,3) : -13 -> -13], [() : -13 -> -14], 
      [(1,2)(3,4) : -13 -> -12] ] ]
gap> c2 := Arrow( Ha4, (1,4,2), -13, -12);;
gap> innc2 := GroupoidInnerAutomorphism( Ha4, c2 );
groupoid homomorphism : Ha4 -> Ha4
[ [ [(1,2,3) : -14 -> -14], [(2,3,4) : -14 -> -14], [() : -14 -> -13], 
      [() : -14 -> -12] ], 
  [ [(1,2,3) : -14 -> -14], [(2,3,4) : -14 -> -14], [(1,4,2) : -14 -> -12], 
      [(1,2,4) : -14 -> -13] ] ]
gap> c12 := c1 * c2;
[(2,4,3) : -14 -> -12]
gap> innc12 := GroupoidInnerAutomorphism( Ha4, c12 );
groupoid homomorphism : Ha4 -> Ha4
[ [ [(1,2,3) : -14 -> -14], [(2,3,4) : -14 -> -14], [() : -14 -> -13], 
      [() : -14 -> -12] ], 
  [ [(1,4,2) : -12 -> -12], [(2,3,4) : -12 -> -12], [(2,3,4) : -12 -> -13], 
      [(2,4,3) : -12 -> -14] ] ]
gap> [ innc1 * innc2 * innc1 = innc12, innc2 * innc1 * innc2 = innc12 ];
[ true, true ]
]]>
</Example>

<ManSection>
   <Oper Name="GroupoidActionByConjugation"
         Arg="gpd" />
   <Filt Name="IsGroupoidAction" 
         Arg='map' Type='Category'/>
   <Attr Name="ActionMap"
         Arg="act" />
<Description>
The operation <C>GroupoidInnerAutomorphism</C>, which produces the conjugation
action of <M>G</M> on itself, does satisfy the conjugation identities 
and so provides a standard example of an action.
<P/>
An action is a record with fields <C>Source</C>, <C>Range</C>
and <C>ActionMap</C>.
<P/>
The examples repeat those in section <Ref Oper="GroupoidInnerAutomorphism"/>:
firstly with a groupoid acting on itself.
<P/> 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> act1 := GroupoidActionByConjugation( Ha4 );
<general mapping: Ha4 -> Aut(Ha4) >
gap> IsGroupoidAction( act1 );
true
gap> amap1 := ActionMap( act1 );;
gap> amap1( h4 ) = inn1;
true
]]>
</Example>

Secondly with an action on a single piece, normal subgroupoid.
<Example>
<![CDATA[
gap> act2 := GroupoidActionByConjugation( Ha4, Nk4 );
<general mapping: Ha4 -> Aut(Nk4) >
gap> IsGroupoidAction( act2 );
true
gap> amap2 := ActionMap( act2 );;
gap> amap2( e4 ) = inn2;
true
]]>
</Example>

Thirly with an action on a homogeneous, discrete subgroupoid.
<Example>
<![CDATA[
gap> act3 := GroupoidActionByConjugation( Ha4, Ma4 );
<general mapping: Ha4 -> Aut(Ma4) >
gap> IsGroupoidAction( act3 );
true
gap> amap3 := ActionMap( act3 );;
gap> amap3( e4 ) = inn3;
true
]]>
</Example>


</Section>

</Chapter>
